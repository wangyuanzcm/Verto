# 自动化脚本集合

## 📋 脚本概览

本文档包含了Verto DevOps环境的所有自动化脚本，帮助您快速部署、管理和维护整个开发环境。

### 🚀 快速导航
- [环境管理脚本](#环境管理脚本)
- [部署脚本](#部署脚本)
- [监控脚本](#监控脚本)
- [备份脚本](#备份脚本)
- [清理脚本](#清理脚本)
- [开发辅助脚本](#开发辅助脚本)

---

## 🔧 环境管理脚本

### 1. 环境初始化脚本 (init-environment.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto DevOps 环境初始化脚本
echo ========================================

:: 检查管理员权限
net session >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ 请以管理员身份运行此脚本
    pause
    exit /b 1
)

echo.
echo 1. 检查系统要求...

:: 检查Docker
docker --version >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ Docker未安装，请先安装Docker Desktop
    pause
    exit /b 1
) else (
    echo ✅ Docker已安装
)

:: 检查Docker Compose
docker-compose --version >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ Docker Compose未安装
    pause
    exit /b 1
) else (
    echo ✅ Docker Compose已安装
)

echo.
echo 2. 创建必要目录...
if not exist "gitlab\config" mkdir gitlab\config
if not exist "gitlab\logs" mkdir gitlab\logs
if not exist "gitlab\data" mkdir gitlab\data
if not exist "jenkins_home" mkdir jenkins_home
if not exist "mysql\data" mkdir mysql\data
if not exist "redis\data" mkdir redis\data
echo ✅ 目录创建完成

echo.
echo 3. 设置目录权限...
icacls gitlab /grant Everyone:(OI)(CI)F /T >nul 2>&1
icacls jenkins_home /grant Everyone:(OI)(CI)F /T >nul 2>&1
icacls mysql /grant Everyone:(OI)(CI)F /T >nul 2>&1
icacls redis /grant Everyone:(OI)(CI)F /T >nul 2>&1
echo ✅ 权限设置完成

echo.
echo 4. 检查环境变量文件...
if not exist ".env.devops" (
    echo ❌ .env.devops文件不存在，正在创建默认配置...
    call :create_env_file
) else (
    echo ✅ 环境变量文件已存在
)

echo.
echo 5. 验证配置文件...
docker-compose -f docker-compose-devops.yml config >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ Docker Compose配置文件有误
    pause
    exit /b 1
) else (
    echo ✅ 配置文件验证通过
)

echo.
echo 6. 拉取Docker镜像...
echo 这可能需要几分钟时间，请耐心等待...
docker-compose -f docker-compose-devops.yml pull
if %errorlevel% neq 0 (
    echo ❌ 镜像拉取失败
    pause
    exit /b 1
) else (
    echo ✅ 镜像拉取完成
)

echo.
echo ========================================
echo 🎉 环境初始化完成！
echo ========================================
echo.
echo 下一步操作：
echo 1. 运行 start-devops.bat 启动服务
echo 2. 等待服务启动完成（约3-5分钟）
echo 3. 访问 http://localhost:8080 (GitLab)
echo 4. 访问 http://localhost:8081 (Jenkins)
echo.
pause
exit /b 0

:create_env_file
echo # Verto DevOps 环境变量配置 > .env.devops
echo. >> .env.devops
echo # MySQL 配置 >> .env.devops
echo MYSQL_ROOT_PASSWORD=Verto123456 >> .env.devops
echo MYSQL_DATABASE=verto >> .env.devops
echo MYSQL_USER=verto >> .env.devops
echo MYSQL_PASSWORD=Verto123456 >> .env.devops
echo. >> .env.devops
echo # GitLab 配置 >> .env.devops
echo GITLAB_HTTP_PORT=8080 >> .env.devops
echo GITLAB_HTTPS_PORT=8443 >> .env.devops
echo GITLAB_SSH_PORT=2222 >> .env.devops
echo. >> .env.devops
echo # Jenkins 配置 >> .env.devops
echo JENKINS_HTTP_PORT=8081 >> .env.devops
echo JENKINS_AGENT_PORT=50000 >> .env.devops
echo. >> .env.devops
echo # Redis 配置 >> .env.devops
echo REDIS_PORT=6379 >> .env.devops
echo ✅ 默认环境变量文件已创建
goto :eof
```

### 2. 环境检查脚本 (check-environment.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto DevOps 环境检查脚本
echo ========================================

set "error_count=0"

echo.
echo 🔍 系统环境检查...

:: 检查操作系统
for /f "tokens=4-5 delims=. " %%i in ('ver') do set VERSION=%%i.%%j
echo 操作系统版本: %VERSION%

:: 检查内存
for /f "skip=1" %%p in ('wmic computersystem get TotalPhysicalMemory') do (
    set /a memory_gb=%%p/1024/1024/1024
    goto :memory_done
)
:memory_done
echo 系统内存: %memory_gb% GB
if %memory_gb% lss 8 (
    echo ⚠️  警告: 建议至少8GB内存
    set /a error_count+=1
)

:: 检查磁盘空间
for /f "tokens=3" %%a in ('dir /-c ^| find "bytes free"') do set free_space=%%a
set /a free_gb=%free_space:~0,-3%/1024/1024
echo 可用磁盘空间: %free_gb% GB
if %free_gb% lss 50 (
    echo ❌ 错误: 磁盘空间不足，至少需要50GB
    set /a error_count+=1
)

echo.
echo 🐳 Docker环境检查...

:: 检查Docker
docker --version >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ Docker未安装或未启动
    set /a error_count+=1
) else (
    for /f "tokens=3" %%a in ('docker --version') do echo Docker版本: %%a
    echo ✅ Docker运行正常
)

:: 检查Docker Compose
docker-compose --version >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ Docker Compose未安装
    set /a error_count+=1
) else (
    for /f "tokens=3" %%a in ('docker-compose --version') do echo Docker Compose版本: %%a
    echo ✅ Docker Compose可用
)

:: 检查Docker资源
echo.
echo Docker资源配置:
docker system df

echo.
echo 🔌 端口检查...

:: 检查端口占用
set "ports=8080 8081 3306 6379"
for %%p in (%ports%) do (
    netstat -ano | findstr :%%p >nul 2>&1
    if !errorlevel! equ 0 (
        echo ⚠️  端口 %%p 已被占用
        for /f "tokens=5" %%a in ('netstat -ano ^| findstr :%%p ^| findstr LISTENING') do (
            for /f "tokens=1" %%b in ('tasklist /FI "PID eq %%a" /FO CSV /NH') do (
                echo    进程: %%b (PID: %%a)
            )
        )
    ) else (
        echo ✅ 端口 %%p 可用
    )
)

echo.
echo 📁 文件和目录检查...

:: 检查必需文件
set "required_files=docker-compose-devops.yml .env.devops"
for %%f in (%required_files%) do (
    if exist "%%f" (
        echo ✅ %%f 存在
    ) else (
        echo ❌ %%f 不存在
        set /a error_count+=1
    )
)

:: 检查目录结构
set "required_dirs=gitlab\config gitlab\logs gitlab\data jenkins_home"
for %%d in (%required_dirs%) do (
    if exist "%%d" (
        echo ✅ 目录 %%d 存在
    ) else (
        echo ❌ 目录 %%d 不存在
        set /a error_count+=1
    )
)

echo.
echo 🌐 网络连接检查...

:: 检查网络连接
ping -n 1 google.com >nul 2>&1
if %errorlevel% equ 0 (
    echo ✅ 外网连接正常
) else (
    echo ⚠️  外网连接异常
)

ping -n 1 docker.io >nul 2>&1
if %errorlevel% equ 0 (
    echo ✅ Docker Hub连接正常
) else (
    echo ⚠️  Docker Hub连接异常
)

echo.
echo ========================================
echo 检查结果汇总
echo ========================================

if %error_count% equ 0 (
    echo 🎉 所有检查通过！环境配置正确
    echo 可以运行 start-devops.bat 启动服务
) else (
    echo ❌ 发现 %error_count% 个问题，请先解决后再启动服务
    echo 参考文档: 环境配置检查清单.md
)

echo.
pause
```

### 3. 服务健康检查脚本 (health-check.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto DevOps 服务健康检查
echo ========================================

set "healthy_count=0"
set "total_services=4"

echo.
echo 🔍 检查容器状态...

:: 检查容器运行状态
for %%s in (gitlab-ce jenkins verto-mysql verto-redis) do (
    docker ps --format "{{.Names}}" | findstr /C:"%%s" >nul 2>&1
    if !errorlevel! equ 0 (
        echo ✅ %%s 容器运行中
        set /a healthy_count+=1
    ) else (
        echo ❌ %%s 容器未运行
    )
)

echo.
echo 🌐 检查服务可访问性...

:: 检查GitLab
curl -s -o nul -w "GitLab (8080): %%{http_code}\n" http://localhost:8080 2>nul
if %errorlevel% equ 0 (
    echo ✅ GitLab Web界面可访问
) else (
    echo ❌ GitLab Web界面不可访问
)

:: 检查Jenkins
curl -s -o nul -w "Jenkins (8081): %%{http_code}\n" http://localhost:8081 2>nul
if %errorlevel% equ 0 (
    echo ✅ Jenkins Web界面可访问
) else (
    echo ❌ Jenkins Web界面不可访问
)

echo.
echo 💾 检查数据库连接...

:: 检查MySQL连接
docker exec verto-mysql mysqladmin ping -h localhost -u root -pVerto123456 >nul 2>&1
if %errorlevel% equ 0 (
    echo ✅ MySQL数据库连接正常
) else (
    echo ❌ MySQL数据库连接失败
)

:: 检查Redis连接
docker exec verto-redis redis-cli ping >nul 2>&1
if %errorlevel% equ 0 (
    echo ✅ Redis缓存连接正常
) else (
    echo ❌ Redis缓存连接失败
)

echo.
echo 📊 资源使用情况...
docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}"

echo.
echo 📁 存储使用情况...
docker system df

echo.
echo ========================================
echo 健康检查结果
echo ========================================

set /a health_percentage=(%healthy_count% * 100) / %total_services%
echo 服务健康度: %health_percentage%% (%healthy_count%/%total_services%)

if %health_percentage% geq 100 (
    echo 🎉 所有服务运行正常！
) else if %health_percentage% geq 75 (
    echo ⚠️  大部分服务正常，请检查异常服务
) else (
    echo ❌ 多个服务异常，请检查系统状态
)

echo.
echo 💡 提示：
echo - 如果服务异常，请查看日志: docker logs [容器名]
echo - 重启异常服务: docker restart [容器名]
echo - 查看详细状态: devops-status.bat
echo.
pause
```

---

## 🚀 部署脚本

### 1. 一键部署脚本 (deploy-all.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto 一键部署脚本
echo ========================================

set "start_time=%time%"

echo.
echo 📋 部署计划:
echo 1. 环境检查
echo 2. 停止现有服务
echo 3. 备份数据
echo 4. 部署DevOps环境
echo 5. 部署应用服务
echo 6. 验证部署结果

echo.
set /p confirm="确认开始部署? (y/N): "
if /i not "%confirm%"=="y" (
    echo 部署已取消
    pause
    exit /b 0
)

echo.
echo 🔍 步骤1: 环境检查...
call check-environment.bat
if %errorlevel% neq 0 (
    echo ❌ 环境检查失败，部署终止
    pause
    exit /b 1
)

echo.
echo 🛑 步骤2: 停止现有服务...
call stop-devops.bat
call stop-app.bat

echo.
echo 💾 步骤3: 备份数据...
call backup-data.bat

echo.
echo 🐳 步骤4: 部署DevOps环境...
call start-devops.bat
if %errorlevel% neq 0 (
    echo ❌ DevOps环境部署失败
    pause
    exit /b 1
)

echo.
echo ⏳ 等待DevOps服务启动完成...
timeout /t 180 /nobreak

echo.
echo 🚀 步骤5: 部署应用服务...
call start-app.bat
if %errorlevel% neq 0 (
    echo ❌ 应用服务部署失败
    pause
    exit /b 1
)

echo.
echo ✅ 步骤6: 验证部署结果...
call health-check.bat

set "end_time=%time%"
echo.
echo ========================================
echo 🎉 部署完成！
echo ========================================
echo 开始时间: %start_time%
echo 结束时间: %end_time%
echo.
echo 🌐 访问地址:
echo - 前端应用: http://localhost:3000
echo - 后端API: http://localhost:8080
echo - GitLab: http://localhost:8080
echo - Jenkins: http://localhost:8081
echo.
echo 📚 更多信息请查看:
echo - 快速启动指南.md
echo - 项目集成指南.md
echo.
pause
```

### 2. 应用启动脚本 (start-app.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto 应用启动脚本
echo ========================================

echo.
echo 🔍 检查前置条件...

:: 检查DevOps服务状态
docker ps | findstr gitlab-ce >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ GitLab服务未运行，请先启动DevOps环境
    echo 运行: start-devops.bat
    pause
    exit /b 1
)

docker ps | findstr verto-mysql >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ MySQL服务未运行，请先启动DevOps环境
    pause
    exit /b 1
)

echo ✅ 前置服务检查通过

echo.
echo 🏗️  构建和启动后端服务...
cd jeecg-boot
if not exist "target" (
    echo 首次运行，正在编译项目...
    call mvn clean compile
    if !errorlevel! neq 0 (
        echo ❌ 后端编译失败
        cd ..
        pause
        exit /b 1
    )
)

echo 启动后端服务...
start "Verto Backend" cmd /k "mvn spring-boot:run -pl jeecg-module-system/jeecg-system-start"

echo ⏳ 等待后端服务启动...
timeout /t 30 /nobreak

echo.
echo 🎨 启动前端服务...
cd ..\jeecgboot-vue3

:: 检查依赖
if not exist "node_modules" (
    echo 首次运行，正在安装依赖...
    call pnpm install
    if !errorlevel! neq 0 (
        echo ❌ 前端依赖安装失败
        cd ..
        pause
        exit /b 1
    )
)

echo 启动前端服务...
start "Verto Frontend" cmd /k "pnpm dev"

cd ..

echo.
echo ⏳ 等待服务启动完成...
timeout /t 60 /nobreak

echo.
echo 🔍 验证服务状态...

:: 检查后端服务
curl -s http://localhost:8080/jeecg-boot/sys/common/403 >nul 2>&1
if %errorlevel% equ 0 (
    echo ✅ 后端服务启动成功
) else (
    echo ⚠️  后端服务可能还在启动中
)

:: 检查前端服务
curl -s http://localhost:3000 >nul 2>&1
if %errorlevel% equ 0 (
    echo ✅ 前端服务启动成功
) else (
    echo ⚠️  前端服务可能还在启动中
)

echo.
echo ========================================
echo 🎉 应用启动完成！
echo ========================================
echo.
echo 🌐 访问地址:
echo - 前端应用: http://localhost:3000
echo - 后端API: http://localhost:8080/jeecg-boot
echo - API文档: http://localhost:8080/jeecg-boot/doc.html
echo.
echo 📝 默认登录信息:
echo - 用户名: admin
echo - 密码: 123456
echo.
echo 💡 提示:
echo - 首次启动可能需要几分钟时间
echo - 如果访问异常，请等待服务完全启动
echo - 查看日志: 在对应的命令行窗口中查看
echo.
pause
```

### 3. 应用停止脚本 (stop-app.bat)

```batch
@echo off
echo ========================================
echo Verto 应用停止脚本
echo ========================================

echo.
echo 🛑 正在停止应用服务...

:: 停止前端服务
echo 停止前端服务...
for /f "tokens=2" %%a in ('tasklist /FI "WINDOWTITLE eq Verto Frontend*" /FO CSV /NH 2^>nul') do (
    if not "%%a"=="INFO:" (
        set pid=%%a
        set pid=!pid:"=!
        echo 终止前端进程 PID: !pid!
        taskkill /PID !pid! /F >nul 2>&1
    )
)

:: 停止后端服务
echo 停止后端服务...
for /f "tokens=2" %%a in ('tasklist /FI "WINDOWTITLE eq Verto Backend*" /FO CSV /NH 2^>nul') do (
    if not "%%a"=="INFO:" (
        set pid=%%a
        set pid=!pid:"=!
        echo 终止后端进程 PID: !pid!
        taskkill /PID !pid! /F >nul 2>&1
    )
)

:: 停止Java进程（备用方法）
echo 检查Java进程...
for /f "tokens=2" %%a in ('tasklist /FI "IMAGENAME eq java.exe" /FO CSV /NH 2^>nul') do (
    if not "%%a"=="INFO:" (
        set pid=%%a
        set pid=!pid:"=!
        echo 发现Java进程 PID: !pid!
        set /p kill_java="是否终止此Java进程? (y/N): "
        if /i "!kill_java!"=="y" (
            taskkill /PID !pid! /F >nul 2>&1
            echo 已终止Java进程 !pid!
        )
    )
)

:: 停止Node.js进程（备用方法）
echo 检查Node.js进程...
for /f "tokens=2" %%a in ('tasklist /FI "IMAGENAME eq node.exe" /FO CSV /NH 2^>nul') do (
    if not "%%a"=="INFO:" (
        set pid=%%a
        set pid=!pid:"=!
        echo 发现Node.js进程 PID: !pid!
        set /p kill_node="是否终止此Node.js进程? (y/N): "
        if /i "!kill_node!"=="y" (
            taskkill /PID !pid! /F >nul 2>&1
            echo 已终止Node.js进程 !pid!
        )
    )
)

echo.
echo ✅ 应用服务停止完成
echo.
pause
```

---

## 📊 监控脚本

### 1. 实时监控脚本 (monitor-realtime.bat)

```batch
@echo off
setlocal enabledelayedexpansion

title Verto DevOps 实时监控

:monitor_loop
cls
echo ========================================
echo Verto DevOps 实时监控
echo 时间: %date% %time%
echo ========================================

echo.
echo 🐳 容器状态:
docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" 2>nul
if %errorlevel% neq 0 (
    echo ❌ Docker服务异常
)

echo.
echo 📊 资源使用:
docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.MemPerc}}" 2>nul

echo.
echo 🌐 服务状态:
call :check_service "GitLab" "http://localhost:8080"
call :check_service "Jenkins" "http://localhost:8081"
call :check_service "前端应用" "http://localhost:3000"
call :check_service "后端API" "http://localhost:8080/jeecg-boot/sys/common/403"

echo.
echo 💾 存储使用:
docker system df 2>nul

echo.
echo 🔄 自动刷新中... (按 Ctrl+C 退出)
timeout /t 10 /nobreak >nul
goto :monitor_loop

:check_service
set service_name=%~1
set service_url=%~2
curl -s -o nul -w "%%{http_code}" %service_url% 2>nul | findstr "200\|302\|403" >nul
if %errorlevel% equ 0 (
    echo ✅ %service_name% 正常
) else (
    echo ❌ %service_name% 异常
)
goto :eof
```

### 2. 性能监控脚本 (monitor-performance.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto DevOps 性能监控报告
echo 生成时间: %date% %time%
echo ========================================

set "report_file=performance_report_%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%.txt"
set "report_file=%report_file: =0%"

echo 正在生成性能报告...

echo ======================================== > %report_file%
echo Verto DevOps 性能监控报告 >> %report_file%
echo 生成时间: %date% %time% >> %report_file%
echo ======================================== >> %report_file%

echo. >> %report_file%
echo 🖥️  系统信息: >> %report_file%
systeminfo | findstr /C:"OS Name" /C:"Total Physical Memory" /C:"Available Physical Memory" >> %report_file%

echo. >> %report_file%
echo 🐳 Docker信息: >> %report_file%
docker info >> %report_file% 2>&1

echo. >> %report_file%
echo 📊 容器资源使用: >> %report_file%
docker stats --no-stream >> %report_file% 2>&1

echo. >> %report_file%
echo 💾 存储使用情况: >> %report_file%
docker system df >> %report_file% 2>&1

echo. >> %report_file%
echo 🔌 端口监听状态: >> %report_file%
netstat -ano | findstr "LISTENING" | findstr ":8080\|:8081\|:3000\|:3306\|:6379" >> %report_file%

echo. >> %report_file%
echo 🌐 服务响应时间测试: >> %report_file%
for %%s in ("GitLab:http://localhost:8080" "Jenkins:http://localhost:8081" "前端:http://localhost:3000") do (
    for /f "tokens=1,2 delims=:" %%a in ("%%s") do (
        echo 测试 %%a... >> %report_file%
        curl -s -o nul -w "响应时间: %%{time_total}s, HTTP状态: %%{http_code}\n" %%b:%%c >> %report_file% 2>&1
    )
)

echo. >> %report_file%
echo 📈 历史数据对比: >> %report_file%
if exist "performance_baseline.txt" (
    echo 与基准数据对比: >> %report_file%
    fc /N performance_baseline.txt %report_file% >> %report_file% 2>&1
) else (
    echo 首次运行，创建基准数据... >> %report_file%
    copy %report_file% performance_baseline.txt >nul
)

echo.
echo ✅ 性能报告已生成: %report_file%
echo.
echo 📊 报告摘要:
echo ============

:: 显示关键指标
echo.
echo 🐳 容器状态:
docker ps --format "table {{.Names}}\t{{.Status}}"

echo.
echo 📊 资源使用:
docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"

echo.
echo 💾 磁盘使用:
docker system df

echo.
echo 📄 完整报告请查看: %report_file%
echo.
pause
```

### 3. 日志监控脚本 (monitor-logs.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto DevOps 日志监控
echo ========================================

echo.
echo 📋 可用的日志监控选项:
echo 1. 实时查看所有容器日志
echo 2. 查看GitLab日志
echo 3. 查看Jenkins日志
echo 4. 查看MySQL日志
echo 5. 查看Redis日志
echo 6. 搜索错误日志
echo 7. 导出日志文件
echo 0. 退出

echo.
set /p choice="请选择操作 (0-7): "

if "%choice%"=="1" goto :all_logs
if "%choice%"=="2" goto :gitlab_logs
if "%choice%"=="3" goto :jenkins_logs
if "%choice%"=="4" goto :mysql_logs
if "%choice%"=="5" goto :redis_logs
if "%choice%"=="6" goto :error_logs
if "%choice%"=="7" goto :export_logs
if "%choice%"=="0" goto :exit
goto :invalid_choice

:all_logs
echo.
echo 🔄 实时查看所有容器日志 (按 Ctrl+C 退出)...
docker-compose -f docker-compose-devops.yml logs -f
goto :menu

:gitlab_logs
echo.
echo 📋 GitLab日志 (最近100行):
docker logs --tail 100 gitlab-ce
echo.
echo 🔄 实时跟踪GitLab日志 (按 Ctrl+C 退出):
docker logs -f gitlab-ce
goto :menu

:jenkins_logs
echo.
echo 📋 Jenkins日志 (最近100行):
docker logs --tail 100 jenkins
echo.
echo 🔄 实时跟踪Jenkins日志 (按 Ctrl+C 退出):
docker logs -f jenkins
goto :menu

:mysql_logs
echo.
echo 📋 MySQL日志 (最近100行):
docker logs --tail 100 verto-mysql
echo.
echo 🔄 实时跟踪MySQL日志 (按 Ctrl+C 退出):
docker logs -f verto-mysql
goto :menu

:redis_logs
echo.
echo 📋 Redis日志 (最近100行):
docker logs --tail 100 verto-redis
echo.
echo 🔄 实时跟踪Redis日志 (按 Ctrl+C 退出):
docker logs -f verto-redis
goto :menu

:error_logs
echo.
echo 🔍 搜索错误日志...
set /p keyword="请输入搜索关键词 (如: error, exception, failed): "
if "%keyword%"=="" set keyword=error

echo.
echo 🔍 在GitLab日志中搜索 "%keyword%":
docker logs gitlab-ce 2>&1 | findstr /i "%keyword%"

echo.
echo 🔍 在Jenkins日志中搜索 "%keyword%":
docker logs jenkins 2>&1 | findstr /i "%keyword%"

echo.
echo 🔍 在MySQL日志中搜索 "%keyword%":
docker logs verto-mysql 2>&1 | findstr /i "%keyword%"

echo.
echo 🔍 在Redis日志中搜索 "%keyword%":
docker logs verto-redis 2>&1 | findstr /i "%keyword%"

pause
goto :menu

:export_logs
echo.
echo 📤 导出日志文件...
set "log_dir=logs_export_%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%"
set "log_dir=%log_dir: =0%"
mkdir "%log_dir%" 2>nul

echo 导出GitLab日志...
docker logs gitlab-ce > "%log_dir%\gitlab.log" 2>&1

echo 导出Jenkins日志...
docker logs jenkins > "%log_dir%\jenkins.log" 2>&1

echo 导出MySQL日志...
docker logs verto-mysql > "%log_dir%\mysql.log" 2>&1

echo 导出Redis日志...
docker logs verto-redis > "%log_dir%\redis.log" 2>&1

echo 导出Docker Compose日志...
docker-compose -f docker-compose-devops.yml logs > "%log_dir%\docker-compose.log" 2>&1

echo 创建日志摘要...
echo Verto DevOps 日志导出 > "%log_dir%\README.txt"
echo 导出时间: %date% %time% >> "%log_dir%\README.txt"
echo. >> "%log_dir%\README.txt"
echo 文件说明: >> "%log_dir%\README.txt"
echo - gitlab.log: GitLab容器日志 >> "%log_dir%\README.txt"
echo - jenkins.log: Jenkins容器日志 >> "%log_dir%\README.txt"
echo - mysql.log: MySQL容器日志 >> "%log_dir%\README.txt"
echo - redis.log: Redis容器日志 >> "%log_dir%\README.txt"
echo - docker-compose.log: Docker Compose日志 >> "%log_dir%\README.txt"

echo.
echo ✅ 日志已导出到目录: %log_dir%
pause
goto :menu

:invalid_choice
echo ❌ 无效选择，请重新输入
pause

:menu
echo.
echo 按任意键返回主菜单...
pause >nul
cls
goto :start

:exit
echo 退出日志监控
exit /b 0

:start
goto :eof
```

---

## 💾 备份脚本

### 1. 数据备份脚本 (backup-data.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto DevOps 数据备份脚本
echo ========================================

set "backup_date=%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%"
set "backup_date=%backup_date: =0%"
set "backup_dir=backup_%backup_date%"

echo.
echo 📋 备份计划:
echo - 备份目录: %backup_dir%
echo - GitLab数据
echo - Jenkins数据
echo - MySQL数据库
echo - Redis数据
echo - 配置文件

echo.
set /p confirm="确认开始备份? (y/N): "
if /i not "%confirm%"=="y" (
    echo 备份已取消
    pause
    exit /b 0
)

echo.
echo 📁 创建备份目录...
mkdir "%backup_dir%" 2>nul
mkdir "%backup_dir%\gitlab" 2>nul
mkdir "%backup_dir%\jenkins" 2>nul
mkdir "%backup_dir%\mysql" 2>nul
mkdir "%backup_dir%\redis" 2>nul
mkdir "%backup_dir%\config" 2>nul

echo.
echo 💾 备份配置文件...
copy "docker-compose-devops.yml" "%backup_dir%\config\" >nul 2>&1
copy ".env.devops" "%backup_dir%\config\" >nul 2>&1
copy "*.bat" "%backup_dir%\config\" >nul 2>&1
copy "*.md" "%backup_dir%\config\" >nul 2>&1
echo ✅ 配置文件备份完成

echo.
echo 🔍 检查容器状态...
docker ps | findstr gitlab-ce >nul 2>&1
set gitlab_running=%errorlevel%

docker ps | findstr jenkins >nul 2>&1
set jenkins_running=%errorlevel%

docker ps | findstr verto-mysql >nul 2>&1
set mysql_running=%errorlevel%

docker ps | findstr verto-redis >nul 2>&1
set redis_running=%errorlevel%

echo.
echo 📦 备份GitLab数据...
if %gitlab_running% equ 0 (
    echo GitLab容器运行中，创建备份...
    docker exec gitlab-ce gitlab-backup create BACKUP=%backup_date% >nul 2>&1
    if !errorlevel! equ 0 (
        echo ✅ GitLab备份创建成功
        docker cp gitlab-ce:/var/opt/gitlab/backups/%backup_date%_gitlab_backup.tar "%backup_dir%\gitlab\" >nul 2>&1
        docker cp gitlab-ce:/etc/gitlab/gitlab.rb "%backup_dir%\gitlab\" >nul 2>&1
        docker cp gitlab-ce:/etc/gitlab/gitlab-secrets.json "%backup_dir%\gitlab\" >nul 2>&1
    ) else (
        echo ⚠️  GitLab备份创建失败，复制数据目录...
        xcopy /E /I /H /Y "gitlab\data" "%backup_dir%\gitlab\data\" >nul 2>&1
    )
) else (
    echo GitLab容器未运行，复制数据目录...
    xcopy /E /I /H /Y "gitlab\data" "%backup_dir%\gitlab\data\" >nul 2>&1
    xcopy /E /I /H /Y "gitlab\config" "%backup_dir%\gitlab\config\" >nul 2>&1
    xcopy /E /I /H /Y "gitlab\logs" "%backup_dir%\gitlab\logs\" >nul 2>&1
)
echo ✅ GitLab数据备份完成

echo.
echo 🔧 备份Jenkins数据...
if %jenkins_running% equ 0 (
    echo Jenkins容器运行中，复制数据...
    docker cp jenkins:/var/jenkins_home "%backup_dir%\jenkins\" >nul 2>&1
) else (
    echo Jenkins容器未运行，复制数据目录...
    xcopy /E /I /H /Y "jenkins_home" "%backup_dir%\jenkins\jenkins_home\" >nul 2>&1
)
echo ✅ Jenkins数据备份完成

echo.
echo 🗄️  备份MySQL数据库...
if %mysql_running% equ 0 (
    echo 导出数据库...
    docker exec verto-mysql mysqldump -u root -pVerto123456 --all-databases > "%backup_dir%\mysql\all_databases.sql" 2>nul
    if !errorlevel! equ 0 (
        echo ✅ MySQL数据库导出成功
    ) else (
        echo ⚠️  数据库导出失败，复制数据目录...
        xcopy /E /I /H /Y "mysql\data" "%backup_dir%\mysql\data\" >nul 2>&1
    )
) else (
    echo MySQL容器未运行，复制数据目录...
    xcopy /E /I /H /Y "mysql\data" "%backup_dir%\mysql\data\" >nul 2>&1
)
echo ✅ MySQL数据备份完成

echo.
echo 📊 备份Redis数据...
if %redis_running% equ 0 (
    echo 创建Redis快照...
    docker exec verto-redis redis-cli BGSAVE >nul 2>&1
    timeout /t 5 /nobreak >nul
    docker cp verto-redis:/data/dump.rdb "%backup_dir%\redis\" >nul 2>&1
) else (
    echo Redis容器未运行，复制数据目录...
    xcopy /E /I /H /Y "redis\data" "%backup_dir%\redis\data\" >nul 2>&1
)
echo ✅ Redis数据备份完成

echo.
echo 📝 创建备份信息文件...
echo Verto DevOps 数据备份 > "%backup_dir%\backup_info.txt"
echo 备份时间: %date% %time% >> "%backup_dir%\backup_info.txt"
echo 备份版本: %backup_date% >> "%backup_dir%\backup_info.txt"
echo. >> "%backup_dir%\backup_info.txt"
echo 备份内容: >> "%backup_dir%\backup_info.txt"
echo - GitLab数据和配置 >> "%backup_dir%\backup_info.txt"
echo - Jenkins数据和配置 >> "%backup_dir%\backup_info.txt"
echo - MySQL数据库 >> "%backup_dir%\backup_info.txt"
echo - Redis数据 >> "%backup_dir%\backup_info.txt"
echo - 系统配置文件 >> "%backup_dir%\backup_info.txt"
echo. >> "%backup_dir%\backup_info.txt"
echo 恢复说明: >> "%backup_dir%\backup_info.txt"
echo 1. 停止所有服务 >> "%backup_dir%\backup_info.txt"
echo 2. 运行 restore-data.bat >> "%backup_dir%\backup_info.txt"
echo 3. 选择此备份目录进行恢复 >> "%backup_dir%\backup_info.txt"

echo.
echo 🗜️  压缩备份文件...
if exist "C:\Program Files\7-Zip\7z.exe" (
    "C:\Program Files\7-Zip\7z.exe" a -tzip "%backup_dir%.zip" "%backup_dir%\*" >nul 2>&1
    if !errorlevel! equ 0 (
        echo ✅ 备份文件已压缩: %backup_dir%.zip
        rmdir /s /q "%backup_dir%" 2>nul
    ) else (
        echo ⚠️  压缩失败，保留原始备份目录
    )
) else (
    echo ⚠️  未找到7-Zip，跳过压缩步骤
)

echo.
echo ========================================
echo 🎉 备份完成！
echo ========================================
echo 备份位置: %backup_dir%
echo 备份时间: %date% %time%
echo.
echo 💡 建议:
echo - 定期备份重要数据
echo - 将备份文件存储到安全位置
echo - 定期测试备份恢复流程
echo.
pause
```

### 2. 数据恢复脚本 (restore-data.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto DevOps 数据恢复脚本
echo ========================================

echo.
echo 🔍 搜索可用的备份...
echo.
echo 可用的备份目录:
set backup_count=0
for /d %%d in (backup_*) do (
    set /a backup_count+=1
    echo !backup_count!. %%d
    set backup_!backup_count!=%%d
)

if %backup_count% equ 0 (
    echo ❌ 未找到备份目录
    echo 请确保备份目录以 "backup_" 开头
    pause
    exit /b 1
)

echo.
set /p backup_choice="请选择要恢复的备份 (1-%backup_count%): "

if %backup_choice% lss 1 (
    echo ❌ 无效选择
    pause
    exit /b 1
)
if %backup_choice% gtr %backup_count% (
    echo ❌ 无效选择
    pause
    exit /b 1
)

call set selected_backup=%%backup_%backup_choice%%%
echo.
echo 选择的备份: %selected_backup%

if exist "%selected_backup%\backup_info.txt" (
    echo.
    echo 📋 备份信息:
    type "%selected_backup%\backup_info.txt"
)

echo.
echo ⚠️  警告: 恢复操作将覆盖现有数据！
set /p confirm="确认恢复此备份? (y/N): "
if /i not "%confirm%"=="y" (
    echo 恢复已取消
    pause
    exit /b 0
)

echo.
echo 🛑 停止所有服务...
call stop-devops.bat
call stop-app.bat

echo.
echo 🗄️  恢复MySQL数据...
if exist "%selected_backup%\mysql\all_databases.sql" (
    echo 启动MySQL容器进行数据恢复...
    docker-compose -f docker-compose-devops.yml up -d verto-mysql
    timeout /t 30 /nobreak
    
    echo 导入数据库...
    docker exec -i verto-mysql mysql -u root -pVerto123456 < "%selected_backup%\mysql\all_databases.sql"
    if !errorlevel! equ 0 (
        echo ✅ MySQL数据恢复成功
    ) else (
        echo ❌ MySQL数据恢复失败
    )
    
    docker stop verto-mysql
) else if exist "%selected_backup%\mysql\data" (
    echo 恢复MySQL数据目录...
    rmdir /s /q "mysql\data" 2>nul
    xcopy /E /I /H /Y "%selected_backup%\mysql\data" "mysql\data\" >nul 2>&1
    echo ✅ MySQL数据目录恢复完成
) else (
    echo ⚠️  未找到MySQL备份数据
)

echo.
echo 📦 恢复GitLab数据...
if exist "%selected_backup%\gitlab\data" (
    echo 恢复GitLab数据目录...
    rmdir /s /q "gitlab\data" 2>nul
    rmdir /s /q "gitlab\config" 2>nul
    rmdir /s /q "gitlab\logs" 2>nul
    
    xcopy /E /I /H /Y "%selected_backup%\gitlab\data" "gitlab\data\" >nul 2>&1
    xcopy /E /I /H /Y "%selected_backup%\gitlab\config" "gitlab\config\" >nul 2>&1
    xcopy /E /I /H /Y "%selected_backup%\gitlab\logs" "gitlab\logs\" >nul 2>&1
    echo ✅ GitLab数据恢复完成
) else (
    echo ⚠️  未找到GitLab备份数据
)

echo.
echo 🔧 恢复Jenkins数据...
if exist "%selected_backup%\jenkins\jenkins_home" (
    echo 恢复Jenkins数据目录...
    rmdir /s /q "jenkins_home" 2>nul
    xcopy /E /I /H /Y "%selected_backup%\jenkins\jenkins_home" "jenkins_home\" >nul 2>&1
    echo ✅ Jenkins数据恢复完成
) else (
    echo ⚠️  未找到Jenkins备份数据
)

echo.
echo 📊 恢复Redis数据...
if exist "%selected_backup%\redis\dump.rdb" (
    echo 恢复Redis数据文件...
    if not exist "redis\data" mkdir "redis\data"
    copy "%selected_backup%\redis\dump.rdb" "redis\data\" >nul 2>&1
    echo ✅ Redis数据恢复完成
) else if exist "%selected_backup%\redis\data" (
    echo 恢复Redis数据目录...
    rmdir /s /q "redis\data" 2>nul
    xcopy /E /I /H /Y "%selected_backup%\redis\data" "redis\data\" >nul 2>&1
    echo ✅ Redis数据目录恢复完成
) else (
    echo ⚠️  未找到Redis备份数据
)

echo.
echo ⚙️  恢复配置文件...
if exist "%selected_backup%\config" (
    copy "%selected_backup%\config\docker-compose-devops.yml" "." >nul 2>&1
    copy "%selected_backup%\config\.env.devops" "." >nul 2>&1
    echo ✅ 配置文件恢复完成
) else (
    echo ⚠️  未找到配置文件备份
)

echo.
echo 🔧 设置文件权限...
icacls gitlab /grant Everyone:(OI)(CI)F /T >nul 2>&1
icacls jenkins_home /grant Everyone:(OI)(CI)F /T >nul 2>&1
icacls mysql /grant Everyone:(OI)(CI)F /T >nul 2>&1
icacls redis /grant Everyone:(OI)(CI)F /T >nul 2>&1

echo.
echo ========================================
echo 🎉 数据恢复完成！
echo ========================================
echo.
echo 📋 恢复摘要:
echo - MySQL数据: 已恢复
echo - GitLab数据: 已恢复
echo - Jenkins数据: 已恢复
echo - Redis数据: 已恢复
echo - 配置文件: 已恢复
echo.
echo 🚀 下一步操作:
echo 1. 运行 start-devops.bat 启动服务
echo 2. 等待服务完全启动
echo 3. 验证数据完整性
echo 4. 测试应用功能
echo.
echo 💡 注意:
echo - 首次启动可能需要较长时间
echo - 请检查服务日志确认启动状态
echo - 如有问题请查看故障排除手册
echo.
pause
```

---

## 🧹 清理脚本

### 1. 系统清理脚本 (cleanup-system.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto DevOps 系统清理脚本
echo ========================================

echo.
echo 📋 清理选项:
echo 1. 清理Docker缓存和无用镜像
echo 2. 清理日志文件
echo 3. 清理临时文件
echo 4. 清理备份文件 (保留最近5个)
echo 5. 完整清理 (包含以上所有)
echo 0. 退出

echo.
set /p choice="请选择清理选项 (0-5): "

if "%choice%"=="1" goto :docker_cleanup
if "%choice%"=="2" goto :log_cleanup
if "%choice%"=="3" goto :temp_cleanup
if "%choice%"=="4" goto :backup_cleanup
if "%choice%"=="5" goto :full_cleanup
if "%choice%"=="0" goto :exit
goto :invalid_choice

:docker_cleanup
echo.
echo 🐳 清理Docker资源...
echo.
echo 当前Docker使用情况:
docker system df

echo.
set /p confirm="确认清理Docker缓存? (y/N): "
if /i not "%confirm%"=="y" goto :menu

echo.
echo 清理停止的容器...
docker container prune -f

echo 清理无用的镜像...
docker image prune -f

echo 清理无用的网络...
docker network prune -f

echo 清理无用的卷...
docker volume prune -f

echo 清理构建缓存...
docker builder prune -f

echo.
echo ✅ Docker清理完成
echo.
echo 清理后Docker使用情况:
docker system df

pause
goto :menu

:log_cleanup
echo.
echo 📝 清理日志文件...

set "log_size=0"
for /r . %%f in (*.log) do (
    set /a log_size+=%%~zf/1024/1024
)
echo 当前日志文件大小: %log_size% MB

echo.
set /p confirm="确认清理日志文件? (y/N): "
if /i not "%confirm%"=="y" goto :menu

echo.
echo 清理应用日志...
del /q /s *.log >nul 2>&1

echo 清理Docker容器日志...
for /f "tokens=1" %%c in ('docker ps -aq') do (
    echo 清理容器 %%c 的日志...
    echo. > $(docker inspect --format='{{.LogPath}}' %%c) 2>nul
)

echo 清理系统临时日志...
del /q "%TEMP%\*.log" >nul 2>&1

echo.
echo ✅ 日志清理完成
pause
goto :menu

:temp_cleanup
echo.
echo 🗂️  清理临时文件...

echo 清理系统临时文件...
del /q /s "%TEMP%\*" >nul 2>&1
del /q /s "%TMP%\*" >nul 2>&1

echo 清理项目临时文件...
del /q /s "*.tmp" >nul 2>&1
del /q /s "*.temp" >nul 2>&1
del /q /s ".DS_Store" >nul 2>&1
del /q /s "Thumbs.db" >nul 2>&1

echo 清理Node.js缓存...
if exist "jeecgboot-vue3\node_modules\.cache" (
    rmdir /s /q "jeecgboot-vue3\node_modules\.cache" 2>nul
)

echo 清理Maven缓存...
if exist "%USERPROFILE%\.m2\repository" (
    echo 清理Maven本地仓库缓存...
    for /d %%d in ("%USERPROFILE%\.m2\repository\*") do (
        if exist "%%d\_remote.repositories" del /q "%%d\_remote.repositories" 2>nul
    )
)

echo.
echo ✅ 临时文件清理完成
pause
goto :menu

:backup_cleanup
echo.
echo 💾 清理备份文件...

echo 当前备份文件:
set backup_count=0
for %%f in (backup_*.zip backup_*) do (
    if exist "%%f" (
        set /a backup_count+=1
        echo !backup_count!. %%f
    )
)

if %backup_count% leq 5 (
    echo 备份文件数量 (%backup_count%) 未超过限制 (5个)，无需清理
    pause
    goto :menu
)

echo.
echo 发现 %backup_count% 个备份文件，将保留最新的5个
set /p confirm="确认清理旧备份? (y/N): "
if /i not "%confirm%"=="y" goto :menu

echo.
echo 清理旧备份文件...
set keep_count=5
set delete_count=0

:: 按时间排序并删除旧文件
for /f "skip=%keep_count%" %%f in ('dir backup_* /b /o-d 2^>nul') do (
    echo 删除旧备份: %%f
    if exist "%%f\" (
        rmdir /s /q "%%f" 2>nul
    ) else (
        del /q "%%f" 2>nul
    )
    set /a delete_count+=1
)

echo.
echo ✅ 已删除 %delete_count% 个旧备份文件
pause
goto :menu

:full_cleanup
echo.
echo 🧹 执行完整清理...
echo.
echo ⚠️  警告: 这将清理所有缓存、日志和临时文件
set /p confirm="确认执行完整清理? (y/N): "
if /i not "%confirm%"=="y" goto :menu

echo.
echo 执行完整清理...
call :docker_cleanup_silent
call :log_cleanup_silent
call :temp_cleanup_silent
call :backup_cleanup_silent

echo.
echo ✅ 完整清理完成
pause
goto :menu

:docker_cleanup_silent
echo 清理Docker资源...
docker container prune -f >nul 2>&1
docker image prune -f >nul 2>&1
docker network prune -f >nul 2>&1
docker volume prune -f >nul 2>&1
docker builder prune -f >nul 2>&1
goto :eof

:log_cleanup_silent
echo 清理日志文件...
del /q /s *.log >nul 2>&1
del /q "%TEMP%\*.log" >nul 2>&1
goto :eof

:temp_cleanup_silent
echo 清理临时文件...
del /q /s "%TEMP%\*" >nul 2>&1
del /q /s "*.tmp" >nul 2>&1
del /q /s "*.temp" >nul 2>&1
goto :eof

:backup_cleanup_silent
echo 清理旧备份...
set keep_count=5
for /f "skip=%keep_count%" %%f in ('dir backup_* /b /o-d 2^>nul') do (
    if exist "%%f\" (
        rmdir /s /q "%%f" 2>nul
    ) else (
        del /q "%%f" 2>nul
    )
)
goto :eof

:invalid_choice
echo ❌ 无效选择，请重新输入
pause

:menu
echo.
echo 按任意键返回主菜单...
pause >nul
cls
goto :start

:exit
echo 退出清理脚本
exit /b 0

:start
goto :eof
```

---

## 🛠️ 开发辅助脚本

### 1. 开发环境快速切换脚本 (dev-switch.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto 开发环境快速切换
echo ========================================

echo.
echo 📋 可用环境:
echo 1. 开发环境 (本地数据库)
echo 2. 测试环境 (Docker数据库)
echo 3. 生产环境 (远程数据库)
echo 4. 查看当前环境
echo 0. 退出

echo.
set /p choice="请选择环境 (0-4): "

if "%choice%"=="1" goto :dev_env
if "%choice%"=="2" goto :test_env
if "%choice%"=="3" goto :prod_env
if "%choice%"=="4" goto :show_current
if "%choice%"=="0" goto :exit
goto :invalid_choice

:dev_env
echo.
echo 🔧 切换到开发环境...
echo 配置本地数据库连接...

:: 备份当前配置
copy "jeecg-boot\jeecg-module-system\jeecg-system-start\src\main\resources\application-dev.yml" "jeecg-boot\jeecg-module-system\jeecg-system-start\src\main\resources\application-dev.yml.bak" >nul 2>&1

:: 创建开发环境配置
echo # 开发环境配置 > temp_config.yml
echo server: >> temp_config.yml
echo   port: 8080 >> temp_config.yml
echo. >> temp_config.yml
echo spring: >> temp_config.yml
echo   datasource: >> temp_config.yml
echo     url: jdbc:mysql://localhost:3306/verto?useUnicode=true^&characterEncoding=UTF-8^&serverTimezone=GMT%%2B8 >> temp_config.yml
echo     username: root >> temp_config.yml
echo     password: 123456 >> temp_config.yml
echo. >> temp_config.yml
echo   redis: >> temp_config.yml
echo     host: localhost >> temp_config.yml
echo     port: 6379 >> temp_config.yml

copy temp_config.yml "jeecg-boot\jeecg-module-system\jeecg-system-start\src\main\resources\application-dev.yml" >nul 2>&1
del temp_config.yml >nul 2>&1

echo ✅ 开发环境配置完成
echo 数据库: localhost:3306
echo Redis: localhost:6379
goto :menu

:test_env
echo.
echo 🧪 切换到测试环境...
echo 配置Docker数据库连接...

:: 创建测试环境配置
echo # 测试环境配置 > temp_config.yml
echo server: >> temp_config.yml
echo   port: 8080 >> temp_config.yml
echo. >> temp_config.yml
echo spring: >> temp_config.yml
echo   datasource: >> temp_config.yml
echo     url: jdbc:mysql://localhost:3306/verto?useUnicode=true^&characterEncoding=UTF-8^&serverTimezone=GMT%%2B8 >> temp_config.yml
echo     username: verto >> temp_config.yml
echo     password: Verto123456 >> temp_config.yml
echo. >> temp_config.yml
echo   redis: >> temp_config.yml
echo     host: localhost >> temp_config.yml
echo     port: 6379 >> temp_config.yml

copy temp_config.yml "jeecg-boot\jeecg-module-system\jeecg-system-start\src\main\resources\application-dev.yml" >nul 2>&1
del temp_config.yml >nul 2>&1

echo ✅ 测试环境配置完成
echo 数据库: Docker MySQL (localhost:3306)
echo Redis: Docker Redis (localhost:6379)
goto :menu

:prod_env
echo.
echo 🚀 切换到生产环境...
echo ⚠️  请手动配置生产环境数据库连接信息

echo.
set /p db_host="数据库主机地址: "
set /p db_port="数据库端口 (默认3306): "
if "%db_port%"=="" set db_port=3306
set /p db_name="数据库名称: "
set /p db_user="数据库用户名: "
set /p db_pass="数据库密码: "
set /p redis_host="Redis主机地址: "
set /p redis_port="Redis端口 (默认6379): "
if "%redis_port%"=="" set redis_port=6379

:: 创建生产环境配置
echo # 生产环境配置 > temp_config.yml
echo server: >> temp_config.yml
echo   port: 8080 >> temp_config.yml
echo. >> temp_config.yml
echo spring: >> temp_config.yml
echo   datasource: >> temp_config.yml
echo     url: jdbc:mysql://%db_host%:%db_port%/%db_name%?useUnicode=true^&characterEncoding=UTF-8^&serverTimezone=GMT%%2B8 >> temp_config.yml
echo     username: %db_user% >> temp_config.yml
echo     password: %db_pass% >> temp_config.yml
echo. >> temp_config.yml
echo   redis: >> temp_config.yml
echo     host: %redis_host% >> temp_config.yml
echo     port: %redis_port% >> temp_config.yml

copy temp_config.yml "jeecg-boot\jeecg-module-system\jeecg-system-start\src\main\resources\application-prod.yml" >nul 2>&1
del temp_config.yml >nul 2>&1

echo ✅ 生产环境配置完成
echo 数据库: %db_host%:%db_port%
echo Redis: %redis_host%:%redis_port%
goto :menu

:show_current
echo.
echo 📋 当前环境配置:
echo.
if exist "jeecg-boot\jeecg-module-system\jeecg-system-start\src\main\resources\application-dev.yml" (
    echo 开发环境配置:
    findstr /C:"url:" /C:"host:" "jeecg-boot\jeecg-module-system\jeecg-system-start\src\main\resources\application-dev.yml" 2>nul
)
echo.
if exist "jeecg-boot\jeecg-module-system\jeecg-system-start\src\main\resources\application-prod.yml" (
    echo 生产环境配置:
    findstr /C:"url:" /C:"host:" "jeecg-boot\jeecg-module-system\jeecg-system-start\src\main\resources\application-prod.yml" 2>nul
)
pause
goto :menu

:invalid_choice
echo ❌ 无效选择，请重新输入
pause

:menu
echo.
echo 按任意键返回主菜单...
pause >nul
cls
goto :start

:exit
echo 退出环境切换
exit /b 0

:start
goto :eof
```

### 2. 代码质量检查脚本 (code-quality.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto 代码质量检查
echo ========================================

echo.
echo 📋 检查选项:
echo 1. 前端代码检查 (ESLint + Prettier)
echo 2. 后端代码检查 (Checkstyle + SpotBugs)
echo 3. 完整代码检查
echo 4. 修复代码格式
echo 0. 退出

echo.
set /p choice="请选择检查选项 (0-4): "

if "%choice%"=="1" goto :frontend_check
if "%choice%"=="2" goto :backend_check
if "%choice%"=="3" goto :full_check
if "%choice%"=="4" goto :fix_format
if "%choice%"=="0" goto :exit
goto :invalid_choice

:frontend_check
echo.
echo 🎨 前端代码质量检查...
cd jeecgboot-vue3

echo 检查ESLint配置...
if not exist ".eslintrc.js" (
    echo ⚠️  ESLint配置文件不存在，创建默认配置...
    call :create_eslint_config
)

echo 运行ESLint检查...
call pnpm run lint
set eslint_result=%errorlevel%

echo 运行Prettier格式检查...
call pnpm run format:check
set prettier_result=%errorlevel%

echo 运行类型检查...
call pnpm run type-check
set type_result=%errorlevel%

cd ..

echo.
echo 📊 前端检查结果:
if %eslint_result% equ 0 (
    echo ✅ ESLint检查通过
) else (
    echo ❌ ESLint检查发现问题
)

if %prettier_result% equ 0 (
    echo ✅ 代码格式检查通过
) else (
    echo ❌ 代码格式需要修复
)

if %type_result% equ 0 (
    echo ✅ TypeScript类型检查通过
) else (
    echo ❌ TypeScript类型检查发现问题
)

pause
goto :menu

:backend_check
echo.
echo ☕ 后端代码质量检查...
cd jeecg-boot

echo 运行Maven编译检查...
call mvn compile
set compile_result=%errorlevel%

echo 运行Checkstyle检查...
call mvn checkstyle:check
set checkstyle_result=%errorlevel%

echo 运行SpotBugs检查...
call mvn spotbugs:check
set spotbugs_result=%errorlevel%

echo 运行单元测试...
call mvn test
set test_result=%errorlevel%

cd ..

echo.
echo 📊 后端检查结果:
if %compile_result% equ 0 (
    echo ✅ 编译检查通过
) else (
    echo ❌ 编译检查发现问题
)

if %checkstyle_result% equ 0 (
    echo ✅ 代码风格检查通过
) else (
    echo ❌ 代码风格检查发现问题
)

if %spotbugs_result% equ 0 (
    echo ✅ 静态分析检查通过
) else (
    echo ❌ 静态分析发现潜在问题
)

if %test_result% equ 0 (
    echo ✅ 单元测试通过
) else (
    echo ❌ 单元测试失败
)

pause
goto :menu

:full_check
echo.
echo 🔍 完整代码质量检查...
call :frontend_check_silent
call :backend_check_silent

echo.
echo 📊 完整检查结果汇总:
echo ========================
echo 前端检查:
echo - ESLint: %frontend_eslint%
echo - Prettier: %frontend_prettier%
echo - TypeScript: %frontend_type%
echo.
echo 后端检查:
echo - 编译: %backend_compile%
echo - Checkstyle: %backend_checkstyle%
echo - SpotBugs: %backend_spotbugs%
echo - 单元测试: %backend_test%

pause
goto :menu

:fix_format
echo.
echo 🔧 修复代码格式...

echo 修复前端代码格式...
cd jeecgboot-vue3
call pnpm run lint:fix
call pnpm run format
cd ..

echo 修复后端代码格式...
cd jeecg-boot
call mvn spotless:apply
cd ..

echo ✅ 代码格式修复完成
pause
goto :menu

:frontend_check_silent
cd jeecgboot-vue3
call pnpm run lint >nul 2>&1
if %errorlevel% equ 0 (set frontend_eslint=✅ 通过) else (set frontend_eslint=❌ 失败)

call pnpm run format:check >nul 2>&1
if %errorlevel% equ 0 (set frontend_prettier=✅ 通过) else (set frontend_prettier=❌ 失败)

call pnpm run type-check >nul 2>&1
if %errorlevel% equ 0 (set frontend_type=✅ 通过) else (set frontend_type=❌ 失败)
cd ..
goto :eof

:backend_check_silent
cd jeecg-boot
call mvn compile >nul 2>&1
if %errorlevel% equ 0 (set backend_compile=✅ 通过) else (set backend_compile=❌ 失败)

call mvn checkstyle:check >nul 2>&1
if %errorlevel% equ 0 (set backend_checkstyle=✅ 通过) else (set backend_checkstyle=❌ 失败)

call mvn spotbugs:check >nul 2>&1
if %errorlevel% equ 0 (set backend_spotbugs=✅ 通过) else (set backend_spotbugs=❌ 失败)

call mvn test >nul 2>&1
if %errorlevel% equ 0 (set backend_test=✅ 通过) else (set backend_test=❌ 失败)
cd ..
goto :eof

:create_eslint_config
echo module.exports = { > .eslintrc.js
echo   root: true, >> .eslintrc.js
echo   env: { >> .eslintrc.js
echo     browser: true, >> .eslintrc.js
echo     es2020: true, >> .eslintrc.js
echo     node: true >> .eslintrc.js
echo   }, >> .eslintrc.js
echo   extends: [ >> .eslintrc.js
echo     'eslint:recommended', >> .eslintrc.js
echo     '@vue/typescript/recommended' >> .eslintrc.js
echo   ], >> .eslintrc.js
echo   rules: { >> .eslintrc.js
echo     'no-console': 'warn', >> .eslintrc.js
echo     'no-debugger': 'warn' >> .eslintrc.js
echo   } >> .eslintrc.js
echo }; >> .eslintrc.js
goto :eof

:invalid_choice
echo ❌ 无效选择，请重新输入
pause

:menu
echo.
echo 按任意键返回主菜单...
pause >nul
cls
goto :start

:exit
echo 退出代码质量检查
exit /b 0

:start
goto :eof
```

### 3. 数据库管理脚本 (database-manager.bat)

```batch
@echo off
setlocal enabledelayedexpansion

echo ========================================
echo Verto 数据库管理工具
echo ========================================

echo.
echo 📋 管理选项:
echo 1. 初始化数据库
echo 2. 备份数据库
echo 3. 恢复数据库
echo 4. 执行SQL脚本
echo 5. 数据库状态检查
echo 6. 清理测试数据
echo 0. 退出

echo.
set /p choice="请选择管理选项 (0-6): "

if "%choice%"=="1" goto :init_db
if "%choice%"=="2" goto :backup_db
if "%choice%"=="3" goto :restore_db
if "%choice%"=="4" goto :execute_sql
if "%choice%"=="5" goto :check_status
if "%choice%"=="6" goto :cleanup_test
if "%choice%"=="0" goto :exit
goto :invalid_choice

:init_db
echo.
echo 🗄️  初始化数据库...

echo 检查MySQL服务状态...
docker ps | findstr verto-mysql >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ MySQL容器未运行，请先启动DevOps环境
    pause
    goto :menu
)

echo 创建数据库...
docker exec verto-mysql mysql -u root -pVerto123456 -e "CREATE DATABASE IF NOT EXISTS verto CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"

echo 检查初始化脚本...
if exist "jeecg-boot\db\jeecgboot-mysql-5.7.sql" (
    echo 执行数据库初始化脚本...
    docker exec -i verto-mysql mysql -u root -pVerto123456 verto < "jeecg-boot\db\jeecgboot-mysql-5.7.sql"
    if !errorlevel! equ 0 (
        echo ✅ 数据库初始化成功
    ) else (
        echo ❌ 数据库初始化失败
    )
) else (
    echo ⚠️  未找到初始化脚本，请检查文件路径
)

pause
goto :menu

:backup_db
echo.
echo 💾 备份数据库...

set "backup_date=%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%"
set "backup_date=%backup_date: =0%"
set "backup_file=db_backup_%backup_date%.sql"

echo 检查MySQL服务状态...
docker ps | findstr verto-mysql >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ MySQL容器未运行，请先启动DevOps环境
    pause
    goto :menu
)

echo 创建备份目录...
if not exist "database_backups" mkdir database_backups

echo 执行数据库备份...
docker exec verto-mysql mysqldump -u root -pVerto123456 --single-transaction --routines --triggers verto > "database_backups\%backup_file%"

if %errorlevel% equ 0 (
    echo ✅ 数据库备份成功
    echo 备份文件: database_backups\%backup_file%
) else (
    echo ❌ 数据库备份失败
)

pause
goto :menu

:restore_db
echo.
echo 🔄 恢复数据库...

echo 可用的备份文件:
set backup_count=0
for %%f in (database_backups\*.sql) do (
    set /a backup_count+=1
    echo !backup_count!. %%f
    set backup_!backup_count!=%%f
)

if %backup_count% equ 0 (
    echo ❌ 未找到备份文件
    pause
    goto :menu
)

echo.
set /p backup_choice="请选择要恢复的备份 (1-%backup_count%): "

if %backup_choice% lss 1 goto :invalid_backup
if %backup_choice% gtr %backup_count% goto :invalid_backup

call set selected_backup=%%backup_%backup_choice%%%

echo.
echo ⚠️  警告: 恢复操作将覆盖现有数据！
set /p confirm="确认恢复备份 %selected_backup%? (y/N): "
if /i not "%confirm%"=="y" (
    echo 恢复已取消
    pause
    goto :menu
)

echo 检查MySQL服务状态...
docker ps | findstr verto-mysql >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ MySQL容器未运行，请先启动DevOps环境
    pause
    goto :menu
)

echo 恢复数据库...
docker exec -i verto-mysql mysql -u root -pVerto123456 verto < "%selected_backup%"

if %errorlevel% equ 0 (
    echo ✅ 数据库恢复成功
) else (
    echo ❌ 数据库恢复失败
)

pause
goto :menu

:execute_sql
echo.
echo 📝 执行SQL脚本...

echo 可用的SQL脚本:
set sql_count=0
for %%f in (*.sql jeecg-boot\db\*.sql) do (
    set /a sql_count+=1
    echo !sql_count!. %%f
    set sql_!sql_count!=%%f
)

if %sql_count% equ 0 (
    echo ❌ 未找到SQL脚本文件
    pause
    goto :menu
)

echo.
set /p sql_choice="请选择要执行的SQL脚本 (1-%sql_count%): "

if %sql_choice% lss 1 goto :invalid_sql
if %sql_choice% gtr %sql_count% goto :invalid_sql

call set selected_sql=%%sql_%sql_choice%%%

echo.
echo 将执行SQL脚本: %selected_sql%
set /p confirm="确认执行? (y/N): "
if /i not "%confirm%"=="y" (
    echo 执行已取消
    pause
    goto :menu
)

echo 检查MySQL服务状态...
docker ps | findstr verto-mysql >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ MySQL容器未运行，请先启动DevOps环境
    pause
    goto :menu
)

echo 执行SQL脚本...
docker exec -i verto-mysql mysql -u root -pVerto123456 verto < "%selected_sql%"

if %errorlevel% equ 0 (
    echo ✅ SQL脚本执行成功
) else (
    echo ❌ SQL脚本执行失败
)

pause
goto :menu

:check_status
echo.
echo 📊 数据库状态检查...

echo 检查MySQL服务状态...
docker ps | findstr verto-mysql >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ MySQL容器未运行
    pause
    goto :menu
)

echo ✅ MySQL容器运行正常

echo.
echo 数据库连接测试...
docker exec verto-mysql mysql -u root -pVerto123456 -e "SELECT 'Database connection successful' as status;"

echo.
echo 数据库信息...
docker exec verto-mysql mysql -u root -pVerto123456 -e "SHOW DATABASES;"

echo.
echo Verto数据库表信息...
docker exec verto-mysql mysql -u root -pVerto123456 verto -e "SHOW TABLES;" 2>nul

echo.
echo 数据库大小...
docker exec verto-mysql mysql -u root -pVerto123456 -e "SELECT table_schema AS 'Database', ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS 'Size (MB)' FROM information_schema.tables WHERE table_schema = 'verto' GROUP BY table_schema;"

pause
goto :menu

:cleanup_test
echo.
echo 🧹 清理测试数据...

echo ⚠️  警告: 这将删除所有测试数据！
set /p confirm="确认清理测试数据? (y/N): "
if /i not "%confirm%"=="y" (
    echo 清理已取消
    pause
    goto :menu
)

echo 检查MySQL服务状态...
docker ps | findstr verto-mysql >nul 2>&1
if %errorlevel% neq 0 (
    echo ❌ MySQL容器未运行，请先启动DevOps环境
    pause
    goto :menu
)

echo 清理测试数据...
docker exec verto-mysql mysql -u root -pVerto123456 verto -e "DELETE FROM sys_log WHERE create_time < DATE_SUB(NOW(), INTERVAL 7 DAY);"
docker exec verto-mysql mysql -u root -pVerto123456 verto -e "DELETE FROM sys_data_log WHERE create_time < DATE_SUB(NOW(), INTERVAL 7 DAY);"

echo ✅ 测试数据清理完成

pause
goto :menu

:invalid_backup
echo ❌ 无效的备份选择
pause
goto :menu

:invalid_sql
echo ❌ 无效的SQL脚本选择
pause
goto :menu

:invalid_choice
echo ❌ 无效选择，请重新输入
pause

:menu
echo.
echo 按任意键返回主菜单...
pause >nul
cls
goto :start

:exit
echo 退出数据库管理工具
exit /b 0

:start
goto :eof
```

---

## 📚 使用说明

### 🚀 快速开始

1. **环境初始化**
   ```batch
   # 首次使用，初始化环境
   init-environment.bat
   ```

2. **启动服务**
   ```batch
   # 启动DevOps环境
   start-devops.bat
   
   # 启动应用服务
   start-app.bat
   ```

3. **监控服务**
   ```batch
   # 实时监控
   monitor-realtime.bat
   
   # 健康检查
   health-check.bat
   ```

### 🔧 维护操作

1. **备份数据**
   ```batch
   # 完整备份
   backup-data.bat
   
   # 数据库备份
   database-manager.bat
   ```

2. **清理系统**
   ```batch
   # 系统清理
   cleanup-system.bat
   ```

3. **代码质量**
   ```batch
   # 代码检查
   code-quality.bat
   ```

### 📋 脚本说明

| 脚本类型 | 脚本名称 | 功能描述 |
|---------|---------|---------|
| 环境管理 | init-environment.bat | 环境初始化 |
| 环境管理 | check-environment.bat | 环境检查 |
| 环境管理 | health-check.bat | 服务健康检查 |
| 部署脚本 | deploy-all.bat | 一键部署 |
| 部署脚本 | start-app.bat | 启动应用 |
| 部署脚本 | stop-app.bat | 停止应用 |
| 监控脚本 | monitor-realtime.bat | 实时监控 |
| 监控脚本 | monitor-performance.bat | 性能监控 |
| 监控脚本 | monitor-logs.bat | 日志监控 |
| 备份脚本 | backup-data.bat | 数据备份 |
| 备份脚本 | restore-data.bat | 数据恢复 |
| 清理脚本 | cleanup-system.bat | 系统清理 |
| 开发辅助 | dev-switch.bat | 环境切换 |
| 开发辅助 | code-quality.bat | 代码质量检查 |
| 开发辅助 | database-manager.bat | 数据库管理 |

### ⚠️ 注意事项

1. **权限要求**: 某些脚本需要管理员权限
2. **依赖检查**: 运行前确保Docker和相关工具已安装
3. **数据安全**: 备份重要数据后再执行清理操作
4. **网络连接**: 确保网络连接正常，用于下载镜像
5. **资源监控**: 定期检查系统资源使用情况

### 🆘 故障排除

如果脚本执行出现问题，请：

1. 检查系统环境和依赖
2. 查看脚本输出的错误信息
3. 参考 `故障排除手册.md`
4. 使用 `check-environment.bat` 诊断环境

### 📞 获取帮助

- 查看详细文档: `README-DevOps.md`
- 快速启动: `快速启动指南.md`
- 故障排除: `故障排除手册.md`
- 项目集成: `项目集成指南.md`

---

**🎉 祝您使用愉快！**