# 后端模块设计文档

## 文档信息
- **版本**: v1.0
- **创建日期**: 2025-01-18
- **最后更新**: 2025-01-18
- **维护人**: 后端开发团队

## 目录
1. [设计原则](#设计原则)
2. [技术架构](#技术架构)
3. [模块划分](#模块划分)
4. [核心模块设计](#核心模块设计)
5. [数据访问层](#数据访问层)
6. [服务层设计](#服务层设计)
7. [控制器层设计](#控制器层设计)
8. [安全认证](#安全认证)
9. [异常处理](#异常处理)
10. [配置管理](#配置管理)
11. [监控告警](#监控告警)
12. [部署方案](#部署方案)

## 设计原则

### 1. 分层架构原则
- **表现层 (Controller)**: 处理HTTP请求，参数验证，响应格式化
- **业务层 (Service)**: 业务逻辑处理，事务管理
- **数据访问层 (Repository)**: 数据持久化，数据库操作
- **实体层 (Entity)**: 数据模型定义

### 2. 模块化原则
- **高内聚**: 模块内部功能紧密相关
- **低耦合**: 模块间依赖最小化
- **单一职责**: 每个模块只负责一个业务领域
- **开闭原则**: 对扩展开放，对修改关闭

### 3. 安全原则
- **最小权限**: 用户只能访问必要的资源
- **数据加密**: 敏感数据加密存储和传输
- **输入验证**: 严格验证所有输入参数
- **审计日志**: 记录关键操作日志

## 技术架构

### 核心框架
- **Spring Boot 2.7.x**: 应用框架
- **Spring Security**: 安全认证
- **Spring Data JPA**: 数据访问
- **MyBatis-Plus**: ORM增强
- **MySQL 8.0**: 主数据库
- **Redis**: 缓存和会话存储

### 工具库
- **Hutool**: Java工具库
- **Jackson**: JSON序列化
- **Validation**: 参数验证
- **Swagger**: API文档
- **Logback**: 日志框架
- **Micrometer**: 监控指标

### 中间件
- **RabbitMQ**: 消息队列
- **Elasticsearch**: 搜索引擎
- **MinIO**: 对象存储
- **Nacos**: 配置中心

## 模块划分

### 项目结构
```
jeecg-boot/
├── jeecg-boot-base/              # 基础模块
│   ├── jeecg-boot-base-core/     # 核心组件
│   ├── jeecg-boot-base-tools/    # 工具类
│   └── jeecg-boot-base-api/      # API接口
├── jeecg-module-system/          # 系统模块
│   ├── jeecg-system-api/         # 系统API
│   ├── jeecg-system-biz/         # 系统业务
│   └── jeecg-system-start/       # 启动模块
├── jeecg-module-requirement/     # 需求管理模块
│   ├── requirement-api/          # 需求API
│   ├── requirement-biz/          # 需求业务
│   └── requirement-start/        # 需求启动
├── jeecg-module-application/     # 应用管理模块
├── jeecg-module-material/        # 物料管理模块
├── jeecg-module-personnel/       # 人员管理模块
├── jeecg-module-project/         # 项目管理模块
└── jeecg-module-integration/     # 集成模块
```

### 模块依赖关系
```
┌─────────────────┐
│   启动模块 (Start) │
├─────────────────┤
│   业务模块 (Biz)   │
├─────────────────┤
│   API模块 (API)   │
├─────────────────┤
│   基础模块 (Base)  │
└─────────────────┘
```

## 核心模块设计

### 1. 需求管理模块 (Requirement)

#### 实体设计
```java
// requirement-api/src/main/java/org/jeecg/modules/requirement/entity/Requirement.java
@Entity
@Table(name = "req_requirement")
@Data
@EqualsAndHashCode(callSuper = true)
@ApiModel(value = "需求实体", description = "需求管理实体类")
public class Requirement extends BaseEntity {
    
    @Id
    @GeneratedValue(generator = "snowflake")
    @GenericGenerator(name = "snowflake", strategy = "org.jeecg.common.util.SnowflakeIdGenerator")
    @ApiModelProperty(value = "主键ID")
    private String id;
    
    @Column(name = "title", nullable = false, length = 200)
    @NotBlank(message = "需求标题不能为空")
    @ApiModelProperty(value = "需求标题")
    private String title;
    
    @Column(name = "description", columnDefinition = "TEXT")
    @ApiModelProperty(value = "需求描述")
    private String description;
    
    @Column(name = "status", length = 20)
    @Enumerated(EnumType.STRING)
    @ApiModelProperty(value = "需求状态")
    private RequirementStatus status = RequirementStatus.DRAFT;
    
    @Column(name = "priority")
    @ApiModelProperty(value = "优先级 1-高 2-中 3-低")
    private Integer priority = 3;
    
    @Column(name = "type", length = 50)
    @ApiModelProperty(value = "需求类型")
    private String type;
    
    @Column(name = "source", length = 50)
    @ApiModelProperty(value = "需求来源")
    private String source;
    
    @Column(name = "assignee_id", length = 32)
    @ApiModelProperty(value = "负责人ID")
    private String assigneeId;
    
    @Column(name = "assignee_name", length = 100)
    @ApiModelProperty(value = "负责人姓名")
    private String assigneeName;
    
    @Column(name = "reporter_id", length = 32)
    @ApiModelProperty(value = "报告人ID")
    private String reporterId;
    
    @Column(name = "reporter_name", length = 100)
    @ApiModelProperty(value = "报告人姓名")
    private String reporterName;
    
    @Column(name = "project_id", length = 32)
    @ApiModelProperty(value = "项目ID")
    private String projectId;
    
    @Column(name = "project_name", length = 100)
    @ApiModelProperty(value = "项目名称")
    private String projectName;
    
    @Column(name = "estimated_hours")
    @ApiModelProperty(value = "预估工时")
    private BigDecimal estimatedHours;
    
    @Column(name = "actual_hours")
    @ApiModelProperty(value = "实际工时")
    private BigDecimal actualHours;
    
    @Column(name = "completion_rate")
    @ApiModelProperty(value = "完成率")
    private Integer completionRate = 0;
    
    @Column(name = "start_date")
    @JsonFormat(timezone = "GMT+8", pattern = "yyyy-MM-dd")
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    @ApiModelProperty(value = "开始日期")
    private Date startDate;
    
    @Column(name = "end_date")
    @JsonFormat(timezone = "GMT+8", pattern = "yyyy-MM-dd")
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    @ApiModelProperty(value = "结束日期")
    private Date endDate;
    
    @Column(name = "zentao_id", length = 32)
    @ApiModelProperty(value = "禅道需求ID")
    private String zentaoId;
    
    @Column(name = "git_branch", length = 100)
    @ApiModelProperty(value = "Git分支")
    private String gitBranch;
    
    @Column(name = "prototype_url", length = 500)
    @ApiModelProperty(value = "原型链接")
    private String prototypeUrl;
    
    @Column(name = "attachment_urls", columnDefinition = "TEXT")
    @ApiModelProperty(value = "附件链接")
    private String attachmentUrls;
    
    @Column(name = "tags", length = 200)
    @ApiModelProperty(value = "标签")
    private String tags;
    
    @Column(name = "remark", columnDefinition = "TEXT")
    @ApiModelProperty(value = "备注")
    private String remark;
}

// 需求状态枚举
public enum RequirementStatus {
    DRAFT("草稿"),
    ACTIVE("进行中"),
    TESTING("测试中"),
    CLOSED("已完成"),
    CANCELLED("已取消");
    
    private final String description;
    
    RequirementStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

#### 数据访问层
```java
// requirement-biz/src/main/java/org/jeecg/modules/requirement/mapper/RequirementMapper.java
@Mapper
public interface RequirementMapper extends BaseMapper<Requirement> {
    
    /**
     * 分页查询需求列表
     */
    @Select("<script>" +
            "SELECT r.*, p.name as project_name " +
            "FROM req_requirement r " +
            "LEFT JOIN proj_project p ON r.project_id = p.id " +
            "WHERE r.del_flag = 0 " +
            "<if test='query.title != null and query.title != \"\"'>" +
            "AND r.title LIKE CONCAT('%', #{query.title}, '%') " +
            "</if>" +
            "<if test='query.status != null'>" +
            "AND r.status = #{query.status} " +
            "</if>" +
            "<if test='query.priority != null'>" +
            "AND r.priority = #{query.priority} " +
            "</if>" +
            "<if test='query.assigneeId != null and query.assigneeId != \"\"'>" +
            "AND r.assignee_id = #{query.assigneeId} " +
            "</if>" +
            "<if test='query.projectId != null and query.projectId != \"\"'>" +
            "AND r.project_id = #{query.projectId} " +
            "</if>" +
            "<if test='query.startDate != null'>" +
            "AND r.start_date >= #{query.startDate} " +
            "</if>" +
            "<if test='query.endDate != null'>" +
            "AND r.end_date <= #{query.endDate} " +
            "</if>" +
            "ORDER BY r.create_time DESC" +
            "</script>")
    IPage<Requirement> selectRequirementPage(Page<Requirement> page, @Param("query") RequirementQueryDTO query);
    
    /**
     * 根据项目ID统计需求数量
     */
    @Select("SELECT status, COUNT(*) as count " +
            "FROM req_requirement " +
            "WHERE project_id = #{projectId} AND del_flag = 0 " +
            "GROUP BY status")
    List<Map<String, Object>> countByProjectAndStatus(@Param("projectId") String projectId);
    
    /**
     * 根据负责人统计需求数量
     */
    @Select("SELECT assignee_id, assignee_name, COUNT(*) as count " +
            "FROM req_requirement " +
            "WHERE del_flag = 0 " +
            "<if test='status != null'>" +
            "AND status = #{status} " +
            "</if>" +
            "GROUP BY assignee_id, assignee_name " +
            "ORDER BY count DESC")
    List<Map<String, Object>> countByAssignee(@Param("status") RequirementStatus status);
    
    /**
     * 获取需求趋势数据
     */
    @Select("SELECT DATE(create_time) as date, COUNT(*) as count " +
            "FROM req_requirement " +
            "WHERE create_time >= #{startDate} AND create_time <= #{endDate} " +
            "AND del_flag = 0 " +
            "GROUP BY DATE(create_time) " +
            "ORDER BY date")
    List<Map<String, Object>> getRequirementTrend(@Param("startDate") Date startDate, 
                                                   @Param("endDate") Date endDate);
}
```

#### 服务层设计
```java
// requirement-biz/src/main/java/org/jeecg/modules/requirement/service/IRequirementService.java
public interface IRequirementService extends IService<Requirement> {
    
    /**
     * 分页查询需求列表
     */
    IPage<RequirementVO> getRequirementPage(Page<Requirement> page, RequirementQueryDTO query);
    
    /**
     * 创建需求
     */
    RequirementVO createRequirement(RequirementDTO dto);
    
    /**
     * 更新需求
     */
    RequirementVO updateRequirement(String id, RequirementDTO dto);
    
    /**
     * 删除需求
     */
    void deleteRequirement(String id);
    
    /**
     * 批量删除需求
     */
    void batchDeleteRequirement(List<String> ids);
    
    /**
     * 获取需求详情
     */
    RequirementVO getRequirementDetail(String id);
    
    /**
     * 更新需求状态
     */
    void updateRequirementStatus(String id, RequirementStatus status);
    
    /**
     * 分配需求
     */
    void assignRequirement(String id, String assigneeId, String assigneeName);
    
    /**
     * 同步禅道需求
     */
    void syncFromZentao(String zentaoId);
    
    /**
     * 创建Git分支
     */
    void createGitBranch(String id, String branchName);
    
    /**
     * 获取需求统计数据
     */
    RequirementStatsVO getRequirementStats(String projectId);
    
    /**
     * 导出需求列表
     */
    void exportRequirements(RequirementQueryDTO query, HttpServletResponse response);
    
    /**
     * 导入需求列表
     */
    void importRequirements(MultipartFile file);
}

// requirement-biz/src/main/java/org/jeecg/modules/requirement/service/impl/RequirementServiceImpl.java
@Service
@Transactional(rollbackFor = Exception.class)
@Slf4j
public class RequirementServiceImpl extends ServiceImpl<RequirementMapper, Requirement> 
        implements IRequirementService {
    
    @Autowired
    private RequirementMapper requirementMapper;
    
    @Autowired
    private IProjectService projectService;
    
    @Autowired
    private IUserService userService;
    
    @Autowired
    private ZentaoIntegrationService zentaoService;
    
    @Autowired
    private GitIntegrationService gitService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public IPage<RequirementVO> getRequirementPage(Page<Requirement> page, RequirementQueryDTO query) {
        // 构建缓存键
        String cacheKey = "requirement:page:" + DigestUtils.md5Hex(JSON.toJSONString(query));
        
        // 尝试从缓存获取
        IPage<RequirementVO> cachedResult = (IPage<RequirementVO>) redisTemplate.opsForValue().get(cacheKey);
        if (cachedResult != null) {
            return cachedResult;
        }
        
        // 查询数据库
        IPage<Requirement> requirementPage = requirementMapper.selectRequirementPage(page, query);
        
        // 转换为VO
        IPage<RequirementVO> result = requirementPage.convert(this::convertToVO);
        
        // 缓存结果（5分钟）
        redisTemplate.opsForValue().set(cacheKey, result, 5, TimeUnit.MINUTES);
        
        return result;
    }
    
    @Override
    public RequirementVO createRequirement(RequirementDTO dto) {
        // 参数验证
        validateRequirementDTO(dto);
        
        // 转换实体
        Requirement requirement = convertToEntity(dto);
        requirement.setStatus(RequirementStatus.DRAFT);
        requirement.setCompletionRate(0);
        
        // 保存到数据库
        this.save(requirement);
        
        // 清除相关缓存
        clearRequirementCache();
        
        // 发送创建事件
        publishRequirementEvent(RequirementEventType.CREATED, requirement);
        
        log.info("创建需求成功: {}", requirement.getId());
        return convertToVO(requirement);
    }
    
    @Override
    public RequirementVO updateRequirement(String id, RequirementDTO dto) {
        // 检查需求是否存在
        Requirement existingRequirement = this.getById(id);
        if (existingRequirement == null) {
            throw new JeecgBootException("需求不存在");
        }
        
        // 检查权限
        checkUpdatePermission(existingRequirement);
        
        // 更新实体
        BeanUtils.copyProperties(dto, existingRequirement, "id", "createTime", "createBy");
        existingRequirement.setUpdateTime(new Date());
        existingRequirement.setUpdateBy(SecurityUtils.getCurrentUsername());
        
        // 保存更新
        this.updateById(existingRequirement);
        
        // 清除缓存
        clearRequirementCache();
        
        // 发送更新事件
        publishRequirementEvent(RequirementEventType.UPDATED, existingRequirement);
        
        log.info("更新需求成功: {}", id);
        return convertToVO(existingRequirement);
    }
    
    @Override
    public void updateRequirementStatus(String id, RequirementStatus status) {
        Requirement requirement = this.getById(id);
        if (requirement == null) {
            throw new JeecgBootException("需求不存在");
        }
        
        // 状态流转验证
        validateStatusTransition(requirement.getStatus(), status);
        
        RequirementStatus oldStatus = requirement.getStatus();
        requirement.setStatus(status);
        requirement.setUpdateTime(new Date());
        requirement.setUpdateBy(SecurityUtils.getCurrentUsername());
        
        // 根据状态更新完成率
        if (status == RequirementStatus.CLOSED) {
            requirement.setCompletionRate(100);
        } else if (status == RequirementStatus.TESTING) {
            requirement.setCompletionRate(80);
        }
        
        this.updateById(requirement);
        
        // 清除缓存
        clearRequirementCache();
        
        // 发送状态变更事件
        publishStatusChangeEvent(requirement, oldStatus, status);
        
        log.info("需求状态变更: {} {} -> {}", id, oldStatus, status);
    }
    
    @Override
    public void syncFromZentao(String zentaoId) {
        try {
            // 从禅道获取需求信息
            ZentaoRequirement zentaoReq = zentaoService.getRequirement(zentaoId);
            if (zentaoReq == null) {
                throw new JeecgBootException("禅道需求不存在: " + zentaoId);
            }
            
            // 检查是否已存在
            Requirement existingReq = this.getOne(
                new QueryWrapper<Requirement>().eq("zentao_id", zentaoId)
            );
            
            if (existingReq != null) {
                // 更新现有需求
                updateFromZentao(existingReq, zentaoReq);
            } else {
                // 创建新需求
                createFromZentao(zentaoReq);
            }
            
            log.info("同步禅道需求成功: {}", zentaoId);
        } catch (Exception e) {
            log.error("同步禅道需求失败: {}", zentaoId, e);
            throw new JeecgBootException("同步禅道需求失败: " + e.getMessage());
        }
    }
    
    @Override
    public void createGitBranch(String id, String branchName) {
        Requirement requirement = this.getById(id);
        if (requirement == null) {
            throw new JeecgBootException("需求不存在");
        }
        
        try {
            // 获取项目Git信息
            Project project = projectService.getById(requirement.getProjectId());
            if (project == null || StringUtils.isBlank(project.getGitUrl())) {
                throw new JeecgBootException("项目Git信息不完整");
            }
            
            // 创建Git分支
            String fullBranchName = gitService.createBranch(
                project.getGitUrl(), 
                branchName, 
                "master"
            );
            
            // 更新需求Git分支信息
            requirement.setGitBranch(fullBranchName);
            requirement.setUpdateTime(new Date());
            requirement.setUpdateBy(SecurityUtils.getCurrentUsername());
            this.updateById(requirement);
            
            log.info("创建Git分支成功: {} -> {}", id, fullBranchName);
        } catch (Exception e) {
            log.error("创建Git分支失败: {}", id, e);
            throw new JeecgBootException("创建Git分支失败: " + e.getMessage());
        }
    }
    
    @Override
    public RequirementStatsVO getRequirementStats(String projectId) {
        RequirementStatsVO stats = new RequirementStatsVO();
        
        // 状态统计
        List<Map<String, Object>> statusStats = requirementMapper.countByProjectAndStatus(projectId);
        stats.setStatusStats(statusStats);
        
        // 负责人统计
        List<Map<String, Object>> assigneeStats = requirementMapper.countByAssignee(null);
        stats.setAssigneeStats(assigneeStats);
        
        // 趋势数据（最近30天）
        Date endDate = new Date();
        Date startDate = DateUtils.addDays(endDate, -30);
        List<Map<String, Object>> trendData = requirementMapper.getRequirementTrend(startDate, endDate);
        stats.setTrendData(trendData);
        
        return stats;
    }
    
    // 私有方法
    private RequirementVO convertToVO(Requirement requirement) {
        RequirementVO vo = new RequirementVO();
        BeanUtils.copyProperties(requirement, vo);
        
        // 设置额外信息
        if (StringUtils.isNotBlank(requirement.getProjectId())) {
            Project project = projectService.getById(requirement.getProjectId());
            if (project != null) {
                vo.setProjectName(project.getName());
            }
        }
        
        return vo;
    }
    
    private Requirement convertToEntity(RequirementDTO dto) {
        Requirement requirement = new Requirement();
        BeanUtils.copyProperties(dto, requirement);
        
        // 设置创建信息
        requirement.setCreateTime(new Date());
        requirement.setCreateBy(SecurityUtils.getCurrentUsername());
        requirement.setDelFlag(0);
        
        return requirement;
    }
    
    private void validateRequirementDTO(RequirementDTO dto) {
        if (StringUtils.isBlank(dto.getTitle())) {
            throw new JeecgBootException("需求标题不能为空");
        }
        
        if (dto.getPriority() == null || dto.getPriority() < 1 || dto.getPriority() > 3) {
            throw new JeecgBootException("优先级必须在1-3之间");
        }
        
        if (StringUtils.isNotBlank(dto.getProjectId())) {
            Project project = projectService.getById(dto.getProjectId());
            if (project == null) {
                throw new JeecgBootException("项目不存在");
            }
        }
    }
    
    private void checkUpdatePermission(Requirement requirement) {
        String currentUser = SecurityUtils.getCurrentUsername();
        
        // 检查是否是创建者或负责人
        if (!currentUser.equals(requirement.getCreateBy()) && 
            !currentUser.equals(requirement.getAssigneeId())) {
            
            // 检查是否有管理员权限
            if (!SecurityUtils.hasRole("admin")) {
                throw new JeecgBootException("无权限修改此需求");
            }
        }
    }
    
    private void validateStatusTransition(RequirementStatus from, RequirementStatus to) {
        // 定义允许的状态流转
        Map<RequirementStatus, Set<RequirementStatus>> allowedTransitions = Map.of(
            RequirementStatus.DRAFT, Set.of(RequirementStatus.ACTIVE, RequirementStatus.CANCELLED),
            RequirementStatus.ACTIVE, Set.of(RequirementStatus.TESTING, RequirementStatus.CANCELLED),
            RequirementStatus.TESTING, Set.of(RequirementStatus.CLOSED, RequirementStatus.ACTIVE),
            RequirementStatus.CLOSED, Set.of(RequirementStatus.ACTIVE),
            RequirementStatus.CANCELLED, Set.of(RequirementStatus.DRAFT)
        );
        
        Set<RequirementStatus> allowed = allowedTransitions.get(from);
        if (allowed == null || !allowed.contains(to)) {
            throw new JeecgBootException(
                String.format("不允许的状态流转: %s -> %s", from.getDescription(), to.getDescription())
            );
        }
    }
    
    private void clearRequirementCache() {
        Set<String> keys = redisTemplate.keys("requirement:*");
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }
    
    private void publishRequirementEvent(RequirementEventType eventType, Requirement requirement) {
        RequirementEvent event = new RequirementEvent();
        event.setEventType(eventType);
        event.setRequirement(requirement);
        event.setTimestamp(new Date());
        event.setOperator(SecurityUtils.getCurrentUsername());
        
        // 发送到消息队列
        rabbitTemplate.convertAndSend("requirement.exchange", "requirement." + eventType.name().toLowerCase(), event);
    }
    
    private void publishStatusChangeEvent(Requirement requirement, RequirementStatus oldStatus, RequirementStatus newStatus) {
        RequirementStatusChangeEvent event = new RequirementStatusChangeEvent();
        event.setRequirementId(requirement.getId());
        event.setOldStatus(oldStatus);
        event.setNewStatus(newStatus);
        event.setTimestamp(new Date());
        event.setOperator(SecurityUtils.getCurrentUsername());
        
        // 发送到消息队列
        rabbitTemplate.convertAndSend("requirement.exchange", "requirement.status.change", event);
    }
}
```

#### 控制器层设计
```java
// requirement-biz/src/main/java/org/jeecg/modules/requirement/controller/RequirementController.java
@RestController
@RequestMapping("/api/requirement")
@Api(tags = "需求管理")
@Slf4j
public class RequirementController {
    
    @Autowired
    private IRequirementService requirementService;
    
    @GetMapping("/list")
    @ApiOperation(value = "分页查询需求列表")
    public Result<IPage<RequirementVO>> getRequirementList(
            @RequestParam(defaultValue = "1") Integer pageNo,
            @RequestParam(defaultValue = "10") Integer pageSize,
            RequirementQueryDTO query) {
        
        Page<Requirement> page = new Page<>(pageNo, pageSize);
        IPage<RequirementVO> result = requirementService.getRequirementPage(page, query);
        
        return Result.OK(result);
    }
    
    @GetMapping("/{id}")
    @ApiOperation(value = "获取需求详情")
    public Result<RequirementVO> getRequirementDetail(@PathVariable String id) {
        RequirementVO requirement = requirementService.getRequirementDetail(id);
        return Result.OK(requirement);
    }
    
    @PostMapping
    @ApiOperation(value = "创建需求")
    @RequiresPermissions("requirement:create")
    public Result<RequirementVO> createRequirement(@RequestBody @Valid RequirementDTO dto) {
        RequirementVO requirement = requirementService.createRequirement(dto);
        return Result.OK(requirement);
    }
    
    @PutMapping("/{id}")
    @ApiOperation(value = "更新需求")
    @RequiresPermissions("requirement:update")
    public Result<RequirementVO> updateRequirement(
            @PathVariable String id, 
            @RequestBody @Valid RequirementDTO dto) {
        
        RequirementVO requirement = requirementService.updateRequirement(id, dto);
        return Result.OK(requirement);
    }
    
    @DeleteMapping("/{id}")
    @ApiOperation(value = "删除需求")
    @RequiresPermissions("requirement:delete")
    public Result<Void> deleteRequirement(@PathVariable String id) {
        requirementService.deleteRequirement(id);
        return Result.OK();
    }
    
    @DeleteMapping("/batch")
    @ApiOperation(value = "批量删除需求")
    @RequiresPermissions("requirement:delete")
    public Result<Void> batchDeleteRequirement(@RequestBody List<String> ids) {
        requirementService.batchDeleteRequirement(ids);
        return Result.OK();
    }
    
    @PutMapping("/{id}/status")
    @ApiOperation(value = "更新需求状态")
    @RequiresPermissions("requirement:update")
    public Result<Void> updateRequirementStatus(
            @PathVariable String id,
            @RequestParam RequirementStatus status) {
        
        requirementService.updateRequirementStatus(id, status);
        return Result.OK();
    }
    
    @PutMapping("/{id}/assign")
    @ApiOperation(value = "分配需求")
    @RequiresPermissions("requirement:assign")
    public Result<Void> assignRequirement(
            @PathVariable String id,
            @RequestParam String assigneeId,
            @RequestParam String assigneeName) {
        
        requirementService.assignRequirement(id, assigneeId, assigneeName);
        return Result.OK();
    }
    
    @PostMapping("/sync/zentao")
    @ApiOperation(value = "同步禅道需求")
    @RequiresPermissions("requirement:sync")
    public Result<Void> syncFromZentao(@RequestParam String zentaoId) {
        requirementService.syncFromZentao(zentaoId);
        return Result.OK();
    }
    
    @PostMapping("/{id}/git-branch")
    @ApiOperation(value = "创建Git分支")
    @RequiresPermissions("requirement:git")
    public Result<Void> createGitBranch(
            @PathVariable String id,
            @RequestParam String branchName) {
        
        requirementService.createGitBranch(id, branchName);
        return Result.OK();
    }
    
    @GetMapping("/stats")
    @ApiOperation(value = "获取需求统计")
    public Result<RequirementStatsVO> getRequirementStats(
            @RequestParam(required = false) String projectId) {
        
        RequirementStatsVO stats = requirementService.getRequirementStats(projectId);
        return Result.OK(stats);
    }
    
    @GetMapping("/export")
    @ApiOperation(value = "导出需求列表")
    @RequiresPermissions("requirement:export")
    public void exportRequirements(
            RequirementQueryDTO query,
            HttpServletResponse response) {
        
        requirementService.exportRequirements(query, response);
    }
    
    @PostMapping("/import")
    @ApiOperation(value = "导入需求列表")
    @RequiresPermissions("requirement:import")
    public Result<Void> importRequirements(@RequestParam("file") MultipartFile file) {
        requirementService.importRequirements(file);
        return Result.OK();
    }
}
```

### 2. 应用管理模块 (Application)

#### 实体设计
```java
// application-api/src/main/java/org/jeecg/modules/application/entity/Application.java
@Entity
@Table(name = "app_application")
@Data
@EqualsAndHashCode(callSuper = true)
@ApiModel(value = "应用实体", description = "应用管理实体类")
public class Application extends BaseEntity {
    
    @Id
    @GeneratedValue(generator = "snowflake")
    @GenericGenerator(name = "snowflake", strategy = "org.jeecg.common.util.SnowflakeIdGenerator")
    @ApiModelProperty(value = "主键ID")
    private String id;
    
    @Column(name = "name", nullable = false, length = 100)
    @NotBlank(message = "应用名称不能为空")
    @ApiModelProperty(value = "应用名称")
    private String name;
    
    @Column(name = "code", nullable = false, length = 50)
    @NotBlank(message = "应用编码不能为空")
    @ApiModelProperty(value = "应用编码")
    private String code;
    
    @Column(name = "description", columnDefinition = "TEXT")
    @ApiModelProperty(value = "应用描述")
    private String description;
    
    @Column(name = "type", length = 20)
    @Enumerated(EnumType.STRING)
    @ApiModelProperty(value = "应用类型")
    private ApplicationType type;
    
    @Column(name = "status", length = 20)
    @Enumerated(EnumType.STRING)
    @ApiModelProperty(value = "应用状态")
    private ApplicationStatus status = ApplicationStatus.ACTIVE;
    
    @Column(name = "git_url", length = 500)
    @ApiModelProperty(value = "Git仓库地址")
    private String gitUrl;
    
    @Column(name = "git_branch", length = 100)
    @ApiModelProperty(value = "Git分支")
    private String gitBranch = "master";
    
    @Column(name = "jenkins_job", length = 200)
    @ApiModelProperty(value = "Jenkins任务")
    private String jenkinsJob;
    
    @Column(name = "deploy_env", length = 500)
    @ApiModelProperty(value = "部署环境")
    private String deployEnv;
    
    @Column(name = "tech_stack", length = 200)
    @ApiModelProperty(value = "技术栈")
    private String techStack;
    
    @Column(name = "owner_id", length = 32)
    @ApiModelProperty(value = "负责人ID")
    private String ownerId;
    
    @Column(name = "owner_name", length = 100)
    @ApiModelProperty(value = "负责人姓名")
    private String ownerName;
    
    @Column(name = "team_id", length = 32)
    @ApiModelProperty(value = "团队ID")
    private String teamId;
    
    @Column(name = "team_name", length = 100)
    @ApiModelProperty(value = "团队名称")
    private String teamName;
    
    @Column(name = "tags", length = 200)
    @ApiModelProperty(value = "标签")
    private String tags;
    
    @Column(name = "config", columnDefinition = "TEXT")
    @ApiModelProperty(value = "配置信息")
    private String config;
    
    @Column(name = "last_deploy_time")
    @JsonFormat(timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm:ss")
    @DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    @ApiModelProperty(value = "最后部署时间")
    private Date lastDeployTime;
    
    @Column(name = "last_deploy_version", length = 100)
    @ApiModelProperty(value = "最后部署版本")
    private String lastDeployVersion;
}

// 应用类型枚举
public enum ApplicationType {
    WEB("Web应用"),
    API("API服务"),
    MOBILE("移动应用"),
    DESKTOP("桌面应用"),
    MICROSERVICE("微服务"),
    LIBRARY("组件库");
    
    private final String description;
    
    ApplicationType(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}

// 应用状态枚举
public enum ApplicationStatus {
    ACTIVE("运行中"),
    INACTIVE("已停用"),
    MAINTENANCE("维护中"),
    ARCHIVED("已归档");
    
    private final String description;
    
    ApplicationStatus(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}
```

## 安全认证

### JWT认证配置
```java
// jeecg-boot-base-core/src/main/java/org/jeecg/config/security/JwtAuthenticationFilter.java
@Component
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtTokenUtil jwtTokenUtil;
    
    @Autowired
    private UserDetailsService userDetailsService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                    HttpServletResponse response, 
                                    FilterChain filterChain) throws ServletException, IOException {
        
        String token = getTokenFromRequest(request);
        
        if (StringUtils.isNotBlank(token)) {
            try {
                // 验证token
                if (jwtTokenUtil.validateToken(token)) {
                    String username = jwtTokenUtil.getUsernameFromToken(token);
                    
                    // 检查token是否在黑名单中
                    String blacklistKey = "jwt:blacklist:" + token;
                    if (redisTemplate.hasKey(blacklistKey)) {
                        log.warn("Token在黑名单中: {}", username);
                        filterChain.doFilter(request, response);
                        return;
                    }
                    
                    // 加载用户信息
                    UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                    
                    // 创建认证对象
                    UsernamePasswordAuthenticationToken authentication = 
                        new UsernamePasswordAuthenticationToken(
                            userDetails, null, userDetails.getAuthorities());
                    
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    
                    // 设置到安全上下文
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                    
                    // 更新token最后访问时间
                    updateTokenLastAccess(token, username);
                }
            } catch (Exception e) {
                log.error("JWT认证失败", e);
            }
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.isNotBlank(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
    
    private void updateTokenLastAccess(String token, String username) {
        String accessKey = "jwt:access:" + username;
        redisTemplate.opsForValue().set(accessKey, System.currentTimeMillis(), 30, TimeUnit.MINUTES);
    }
}
```

### 权限控制
```java
// jeecg-boot-base-core/src/main/java/org/jeecg/config/security/PermissionService.java
@Service
@Slf4j
public class PermissionService {
    
    @Autowired
    private ISysUserService userService;
    
    @Autowired
    private ISysRoleService roleService;
    
    @Autowired
    private ISysPermissionService permissionService;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    /**
     * 检查用户是否有指定权限
     */
    public boolean hasPermission(String permission) {
        String username = SecurityUtils.getCurrentUsername();
        if (StringUtils.isBlank(username)) {
            return false;
        }
        
        // 超级管理员拥有所有权限
        if ("admin".equals(username)) {
            return true;
        }
        
        // 从缓存获取用户权限
        Set<String> userPermissions = getUserPermissions(username);
        
        return userPermissions.contains(permission) || userPermissions.contains("*:*:*");
    }
    
    /**
     * 检查用户是否有指定角色
     */
    public boolean hasRole(String role) {
        String username = SecurityUtils.getCurrentUsername();
        if (StringUtils.isBlank(username)) {
            return false;
        }
        
        Set<String> userRoles = getUserRoles(username);
        return userRoles.contains(role) || userRoles.contains("admin");
    }
    
    /**
     * 检查用户是否可以访问指定资源
     */
    public boolean canAccess(String resourceType, String resourceId, String action) {
        String username = SecurityUtils.getCurrentUsername();
        if (StringUtils.isBlank(username)) {
            return false;
        }
        
        // 构建权限字符串
        String permission = String.format("%s:%s:%s", resourceType, action, resourceId);
        
        return hasPermission(permission);
    }
    
    /**
     * 获取用户权限列表
     */
    @Cacheable(value = "user:permissions", key = "#username")
    public Set<String> getUserPermissions(String username) {
        Set<String> permissions = new HashSet<>();
        
        try {
            // 获取用户信息
            SysUser user = userService.getUserByName(username);
            if (user == null) {
                return permissions;
            }
            
            // 获取用户角色
            List<SysRole> roles = roleService.getUserRoles(user.getId());
            
            // 获取角色权限
            for (SysRole role : roles) {
                List<SysPermission> rolePermissions = permissionService.getRolePermissions(role.getId());
                for (SysPermission permission : rolePermissions) {
                    if (StringUtils.isNotBlank(permission.getPerms())) {
                        permissions.add(permission.getPerms());
                    }
                }
            }
            
        } catch (Exception e) {
            log.error("获取用户权限失败: {}", username, e);
        }
        
        return permissions;
    }
    
    /**
     * 获取用户角色列表
     */
    @Cacheable(value = "user:roles", key = "#username")
    public Set<String> getUserRoles(String username) {
        Set<String> roles = new HashSet<>();
        
        try {
            SysUser user = userService.getUserByName(username);
            if (user != null) {
                List<SysRole> userRoles = roleService.getUserRoles(user.getId());
                for (SysRole role : userRoles) {
                    roles.add(role.getRoleCode());
                }
            }
        } catch (Exception e) {
            log.error("获取用户角色失败: {}", username, e);
        }
        
        return roles;
    }
    
    /**
     * 清除用户权限缓存
     */
    public void clearUserPermissionCache(String username) {
        redisTemplate.delete("user:permissions::" + username);
        redisTemplate.delete("user:roles::" + username);
    }
}
```

## 异常处理

### 全局异常处理器
```java
// jeecg-boot-base-core/src/main/java/org/jeecg/config/exception/GlobalExceptionHandler.java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    /**
     * 业务异常处理
     */
    @ExceptionHandler(JeecgBootException.class)
    public Result<String> handleBusinessException(JeecgBootException e) {
        log.error("业务异常: {}", e.getMessage());
        return Result.error(e.getMessage());
    }
    
    /**
     * 参数验证异常处理
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<String> handleValidationException(MethodArgumentNotValidException e) {
        StringBuilder errorMsg = new StringBuilder();
        
        for (FieldError error : e.getBindingResult().getFieldErrors()) {
            errorMsg.append(error.getField()).append(": ").append(error.getDefaultMessage()).append("; ");
        }
        
        log.error("参数验证失败: {}", errorMsg.toString());
        return Result.error("参数验证失败: " + errorMsg.toString());
    }
    
    /**
     * 权限不足异常处理
     */
    @ExceptionHandler(AccessDeniedException.class)
    public Result<String> handleAccessDeniedException(AccessDeniedException e) {
        log.error("权限不足: {}", e.getMessage());
        return Result.error(403, "权限不足");
    }
    
    /**
     * 认证失败异常处理
     */
    @ExceptionHandler(AuthenticationException.class)
    public Result<String> handleAuthenticationException(AuthenticationException e) {
        log.error("认证失败: {}", e.getMessage());
        return Result.error(401, "认证失败");
    }
    
    /**
     * 数据库异常处理
     */
    @ExceptionHandler(DataAccessException.class)
    public Result<String> handleDataAccessException(DataAccessException e) {
        log.error("数据库操作异常", e);
        return Result.error("数据库操作失败");
    }
    
    /**
     * 系统异常处理
     */
    @ExceptionHandler(Exception.class)
    public Result<String> handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error("系统内部错误");
    }
    
    /**
     * 404异常处理
     */
    @ExceptionHandler(NoHandlerFoundException.class)
    public Result<String> handleNotFoundException(NoHandlerFoundException e) {
        log.error("接口不存在: {}", e.getRequestURL());
        return Result.error(404, "接口不存在");
    }
    
    /**
     * 请求方法不支持异常处理
     */
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public Result<String> handleMethodNotSupportedException(HttpRequestMethodNotSupportedException e) {
        log.error("请求方法不支持: {}", e.getMethod());
        return Result.error(405, "请求方法不支持");
    }
    
    /**
     * 媒体类型不支持异常处理
     */
    @ExceptionHandler(HttpMediaTypeNotSupportedException.class)
    public Result<String> handleMediaTypeNotSupportedException(HttpMediaTypeNotSupportedException e) {
        log.error("媒体类型不支持: {}", e.getContentType());
        return Result.error(415, "媒体类型不支持");
    }
}
```

## 配置管理

### 应用配置
```yaml
# application.yml
server:
  port: 8080
  servlet:
    context-path: /jeecg-boot
  compression:
    enabled: true
    mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json
    min-response-size: 1024

spring:
  application:
    name: jeecg-boot-system
  profiles:
    active: @spring.active@
  
  # 数据源配置
  datasource:
    dynamic:
      primary: master
      strict: false
      datasource:
        master:
          url: jdbc:mysql://localhost:3306/verto?characterEncoding=UTF-8&useUnicode=true&useSSL=false&tinyInt1isBit=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Shanghai
          username: ${DB_USERNAME:root}
          password: ${DB_PASSWORD:123456}
          driver-class-name: com.mysql.cj.jdbc.Driver
          type: com.alibaba.druid.pool.DruidDataSource
          druid:
            initial-size: 5
            min-idle: 5
            max-active: 20
            max-wait: 60000
            time-between-eviction-runs-millis: 60000
            min-evictable-idle-time-millis: 300000
            validation-query: SELECT 1
            test-while-idle: true
            test-on-borrow: false
            test-on-return: false
            pool-prepared-statements: true
            max-pool-prepared-statement-per-connection-size: 20
            filters: stat,wall,slf4j
            connection-properties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000
  
  # Redis配置
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    database: ${REDIS_DATABASE:0}
    timeout: 6000ms
    lettuce:
      pool:
        max-active: 8
        max-wait: -1ms
        max-idle: 8
        min-idle: 0
  
  # JPA配置
  jpa:
    hibernate:
      ddl-auto: none
      naming:
        physical-strategy: org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
        format_sql: true
  
  # 文件上传配置
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 100MB
  
  # 消息队列配置
  rabbitmq:
    host: ${RABBITMQ_HOST:localhost}
    port: ${RABBITMQ_PORT:5672}
    username: ${RABBITMQ_USERNAME:guest}
    password: ${RABBITMQ_PASSWORD:guest}
    virtual-host: ${RABBITMQ_VHOST:/}
    listener:
      simple:
        retry:
          enabled: true
          max-attempts: 3
          initial-interval: 1000ms

# MyBatis-Plus配置
mybatis-plus:
  mapper-locations: classpath*:org/jeecg/**/xml/*Mapper.xml
  global-config:
    db-config:
      id-type: ASSIGN_ID
      table-underline: true
      logic-delete-field: delFlag
      logic-delete-value: 1
      logic-not-delete-value: 0
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: false
    call-setters-on-nulls: true
    jdbc-type-for-null: 'null'

# JWT配置
jeecg:
  jwt:
    secret: ${JWT_SECRET:jeecg-boot-secret-key}
    expire: ${JWT_EXPIRE:86400}
    refresh-expire: ${JWT_REFRESH_EXPIRE:604800}
  
  # 文件存储配置
  file:
    storage:
      type: ${FILE_STORAGE_TYPE:local}
      local:
        path: ${FILE_LOCAL_PATH:./uploads}
      minio:
        endpoint: ${MINIO_ENDPOINT:http://localhost:9000}
        access-key: ${MINIO_ACCESS_KEY:minioadmin}
        secret-key: ${MINIO_SECRET_KEY:minioadmin}
        bucket: ${MINIO_BUCKET:jeecg-boot}
  
  # 集成配置
  integration:
    zentao:
      enabled: ${ZENTAO_ENABLED:false}
      url: ${ZENTAO_URL:http://localhost/zentao}
      username: ${ZENTAO_USERNAME:admin}
      password: ${ZENTAO_PASSWORD:123456}
    
    gitlab:
      enabled: ${GITLAB_ENABLED:false}
      url: ${GITLAB_URL:http://localhost}
      token: ${GITLAB_TOKEN:}
    
    jenkins:
      enabled: ${JENKINS_ENABLED:false}
      url: ${JENKINS_URL:http://localhost:8080}
      username: ${JENKINS_USERNAME:admin}
      password: ${JENKINS_PASSWORD:123456}

# 监控配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: when-authorized
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      environment: ${spring.profiles.active}

# 日志配置
logging:
  level:
    org.jeecg: ${LOG_LEVEL:INFO}
    org.springframework.security: WARN
    org.hibernate.SQL: ${SQL_LOG_LEVEL:WARN}
    org.hibernate.type.descriptor.sql.BasicBinder: WARN
  pattern:
    console: "%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"
  file:
    name: logs/${spring.application.name}.log
    max-size: 100MB
    max-history: 30
```

### 环境配置
```yaml
# application-dev.yml (开发环境)
spring:
  datasource:
    dynamic:
      datasource:
        master:
          url: jdbc:mysql://localhost:3306/verto_dev?characterEncoding=UTF-8&useUnicode=true&useSSL=false&tinyInt1isBit=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Shanghai
  
  jpa:
    show-sql: true
    hibernate:
      ddl-auto: update

logging:
  level:
    org.jeecg: DEBUG
    org.hibernate.SQL: DEBUG

jeecg:
  integration:
    zentao:
      enabled: true
      url: http://dev-zentao.company.com
    gitlab:
      enabled: true
      url: http://dev-gitlab.company.com
    jenkins:
      enabled: true
      url: http://dev-jenkins.company.com

---
# application-prod.yml (生产环境)
spring:
  datasource:
    dynamic:
      datasource:
        master:
          url: jdbc:mysql://prod-mysql:3306/verto?characterEncoding=UTF-8&useUnicode=true&useSSL=false&tinyInt1isBit=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Shanghai
          username: ${DB_USERNAME}
          password: ${DB_PASSWORD}
  
  redis:
    host: prod-redis
    password: ${REDIS_PASSWORD}
  
  rabbitmq:
    host: prod-rabbitmq
    username: ${RABBITMQ_USERNAME}
    password: ${RABBITMQ_PASSWORD}

logging:
  level:
    org.jeecg: WARN
    root: WARN

jeecg:
  integration:
    zentao:
      enabled: true
      url: ${ZENTAO_URL}
      username: ${ZENTAO_USERNAME}
      password: ${ZENTAO_PASSWORD}
    gitlab:
      enabled: true
      url: ${GITLAB_URL}
      token: ${GITLAB_TOKEN}
    jenkins:
      enabled: true
      url: ${JENKINS_URL}
      username: ${JENKINS_USERNAME}
      password: ${JENKINS_PASSWORD}
```

## 监控告警

### 健康检查
```java
// jeecg-boot-base-core/src/main/java/org/jeecg/config/health/CustomHealthIndicator.java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Autowired
    private DataSource dataSource;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public Health health() {
        Health.Builder builder = new Health.Builder();
        
        try {
            // 检查数据库连接
            checkDatabase(builder);
            
            // 检查Redis连接
            checkRedis(builder);
            
            // 检查磁盘空间
            checkDiskSpace(builder);
            
            // 检查内存使用
            checkMemory(builder);
            
            builder.up();
        } catch (Exception e) {
            builder.down(e);
        }
        
        return builder.build();
    }
    
    private void checkDatabase(Health.Builder builder) {
        try (Connection connection = dataSource.getConnection()) {
            if (connection.isValid(3)) {
                builder.withDetail("database", "UP");
            } else {
                builder.withDetail("database", "DOWN");
            }
        } catch (Exception e) {
            builder.withDetail("database", "DOWN - " + e.getMessage());
        }
    }
    
    private void checkRedis(Health.Builder builder) {
        try {
            redisTemplate.opsForValue().set("health:check", "ok", 10, TimeUnit.SECONDS);
            String result = (String) redisTemplate.opsForValue().get("health:check");
            if ("ok".equals(result)) {
                builder.withDetail("redis", "UP");
            } else {
                builder.withDetail("redis", "DOWN");
            }
        } catch (Exception e) {
            builder.withDetail("redis", "DOWN - " + e.getMessage());
        }
    }
    
    private void checkDiskSpace(Health.Builder builder) {
        File root = new File("/");
        long totalSpace = root.getTotalSpace();
        long freeSpace = root.getFreeSpace();
        double usagePercent = (double) (totalSpace - freeSpace) / totalSpace * 100;
        
        builder.withDetail("disk.total", FileUtils.byteCountToDisplaySize(totalSpace));
        builder.withDetail("disk.free", FileUtils.byteCountToDisplaySize(freeSpace));
        builder.withDetail("disk.usage", String.format("%.2f%%", usagePercent));
        
        if (usagePercent > 90) {
            builder.withDetail("disk.status", "WARNING - High disk usage");
        } else {
            builder.withDetail("disk.status", "OK");
        }
    }
    
    private void checkMemory(Health.Builder builder) {
        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        double usagePercent = (double) usedMemory / totalMemory * 100;
        
        builder.withDetail("memory.total", FileUtils.byteCountToDisplaySize(totalMemory));
        builder.withDetail("memory.used", FileUtils.byteCountToDisplaySize(usedMemory));
        builder.withDetail("memory.free", FileUtils.byteCountToDisplaySize(freeMemory));
        builder.withDetail("memory.usage", String.format("%.2f%%", usagePercent));
        
        if (usagePercent > 85) {
            builder.withDetail("memory.status", "WARNING - High memory usage");
        } else {
            builder.withDetail("memory.status", "OK");
        }
    }
}
```

### 性能监控
```java
// jeecg-boot-base-core/src/main/java/org/jeecg/config/metrics/CustomMetrics.java
@Component
@Slf4j
public class CustomMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Counter requestCounter;
    private final Timer requestTimer;
    private final Gauge activeUsers;
    
    public CustomMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        // 请求计数器
        this.requestCounter = Counter.builder("http.requests.total")
            .description("Total HTTP requests")
            .register(meterRegistry);
        
        // 请求耗时
        this.requestTimer = Timer.builder("http.requests.duration")
            .description("HTTP request duration")
            .register(meterRegistry);
        
        // 活跃用户数
        this.activeUsers = Gauge.builder("users.active")
            .description("Active users count")
            .register(meterRegistry, this, CustomMetrics::getActiveUserCount);
    }
    
    public void incrementRequestCount(String method, String uri, String status) {
        requestCounter.increment(
            Tags.of(
                "method", method,
                "uri", uri,
                "status", status
            )
        );
    }
    
    public Timer.Sample startRequestTimer() {
        return Timer.start(meterRegistry);
    }
    
    public void recordRequestTime(Timer.Sample sample, String method, String uri) {
        sample.stop(Timer.builder("http.requests.duration")
            .tags("method", method, "uri", uri)
            .register(meterRegistry));
    }
    
    private double getActiveUserCount() {
        // 从Redis获取活跃用户数
        try {
            Set<String> activeTokens = redisTemplate.keys("jwt:access:*");
            return activeTokens != null ? activeTokens.size() : 0;
        } catch (Exception e) {
            log.error("获取活跃用户数失败", e);
            return 0;
        }
    }
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
}
```

### 告警配置
```java
// jeecg-boot-base-core/src/main/java/org/jeecg/config/alert/AlertService.java
@Service
@Slf4j
public class AlertService {
    
    @Autowired
    private JavaMailSender mailSender;
    
    @Value("${spring.mail.username}")
    private String fromEmail;
    
    @Value("${jeecg.alert.email.to}")
    private String[] toEmails;
    
    @Value("${jeecg.alert.webhook.url:}")
    private String webhookUrl;
    
    /**
     * 发送系统告警
     */
    public void sendAlert(AlertLevel level, String title, String message) {
        AlertMessage alert = new AlertMessage();
        alert.setLevel(level);
        alert.setTitle(title);
        alert.setMessage(message);
        alert.setTimestamp(new Date());
        alert.setHostname(getHostname());
        
        // 异步发送告警
        CompletableFuture.runAsync(() -> {
            try {
                // 发送邮件告警
                sendEmailAlert(alert);
                
                // 发送Webhook告警
                if (StringUtils.isNotBlank(webhookUrl)) {
                    sendWebhookAlert(alert);
                }
                
                // 记录告警日志
                log.warn("系统告警: [{}] {} - {}", level, title, message);
                
            } catch (Exception e) {
                log.error("发送告警失败", e);
            }
        });
    }
    
    private void sendEmailAlert(AlertMessage alert) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8");
            
            helper.setFrom(fromEmail);
            helper.setTo(toEmails);
            helper.setSubject(String.format("[%s] %s", alert.getLevel(), alert.getTitle()));
            
            String content = buildEmailContent(alert);
            helper.setText(content, true);
            
            mailSender.send(message);
            
        } catch (Exception e) {
            log.error("发送邮件告警失败", e);
        }
    }
    
    private void sendWebhookAlert(AlertMessage alert) {
        try {
            RestTemplate restTemplate = new RestTemplate();
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            
            Map<String, Object> payload = new HashMap<>();
            payload.put("level", alert.getLevel());
            payload.put("title", alert.getTitle());
            payload.put("message", alert.getMessage());
            payload.put("timestamp", alert.getTimestamp());
            payload.put("hostname", alert.getHostname());
            
            HttpEntity<Map<String, Object>> request = new HttpEntity<>(payload, headers);
            restTemplate.postForEntity(webhookUrl, request, String.class);
            
        } catch (Exception e) {
            log.error("发送Webhook告警失败", e);
        }
    }
    
    private String buildEmailContent(AlertMessage alert) {
        return String.format(
            "<html><body>" +
            "<h2>系统告警通知</h2>" +
            "<p><strong>告警级别:</strong> %s</p>" +
            "<p><strong>告警标题:</strong> %s</p>" +
            "<p><strong>告警内容:</strong> %s</p>" +
            "<p><strong>发生时间:</strong> %s</p>" +
            "<p><strong>主机名称:</strong> %s</p>" +
            "</body></html>",
            alert.getLevel(),
            alert.getTitle(),
            alert.getMessage(),
            new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(alert.getTimestamp()),
            alert.getHostname()
        );
    }
    
    private String getHostname() {
        try {
            return InetAddress.getLocalHost().getHostName();
        } catch (Exception e) {
            return "unknown";
        }
    }
}

// 告警级别枚举
public enum AlertLevel {
    INFO("信息"),
    WARNING("警告"),
    ERROR("错误"),
    CRITICAL("严重");
    
    private final String description;
    
    AlertLevel(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
}

// 告警消息实体
@Data
public class AlertMessage {
    private AlertLevel level;
    private String title;
    private String message;
    private Date timestamp;
    private String hostname;
}
```

## 部署方案

### Docker配置
```dockerfile
# Dockerfile
FROM openjdk:8-jre-alpine

# 设置时区
RUN apk add --no-cache tzdata && \
    ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo "Asia/Shanghai" > /etc/timezone

# 创建应用目录
WORKDIR /app

# 复制应用文件
COPY target/jeecg-boot-system.jar app.jar
COPY docker/entrypoint.sh entrypoint.sh

# 设置执行权限
RUN chmod +x entrypoint.sh

# 创建日志目录
RUN mkdir -p /app/logs

# 暴露端口
EXPOSE 8080

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/jeecg-boot/actuator/health || exit 1

# 启动应用
ENTRYPOINT ["./entrypoint.sh"]
```

```bash
#!/bin/bash
# docker/entrypoint.sh

# 设置JVM参数
JAVA_OPTS="-Xms512m -Xmx1024m"
JAVA_OPTS="$JAVA_OPTS -XX:+UseG1GC"
JAVA_OPTS="$JAVA_OPTS -XX:MaxGCPauseMillis=200"
JAVA_OPTS="$JAVA_OPTS -XX:+PrintGCDetails"
JAVA_OPTS="$JAVA_OPTS -XX:+PrintGCTimeStamps"
JAVA_OPTS="$JAVA_OPTS -Xloggc:/app/logs/gc.log"
JAVA_OPTS="$JAVA_OPTS -XX:+HeapDumpOnOutOfMemoryError"
JAVA_OPTS="$JAVA_OPTS -XX:HeapDumpPath=/app/logs/"

# 设置应用参数
APP_OPTS="--spring.profiles.active=${SPRING_PROFILES_ACTIVE:-prod}"
APP_OPTS="$APP_OPTS --server.port=${SERVER_PORT:-8080}"

# 启动应用
exec java $JAVA_OPTS -jar app.jar $APP_OPTS
```

### Docker Compose配置
```yaml
# docker-compose.yml
version: '3.8'

services:
  # 应用服务
  jeecg-boot:
    build: .
    container_name: jeecg-boot-system
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - DB_HOST=mysql
      - DB_USERNAME=root
      - DB_PASSWORD=123456
      - REDIS_HOST=redis
      - RABBITMQ_HOST=rabbitmq
    depends_on:
      - mysql
      - redis
      - rabbitmq
    volumes:
      - ./logs:/app/logs
      - ./uploads:/app/uploads
    networks:
      - verto-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/jeecg-boot/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
  
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: verto-mysql
    environment:
      - MYSQL_ROOT_PASSWORD=123456
      - MYSQL_DATABASE=verto
      - MYSQL_CHARACTER_SET_SERVER=utf8mb4
      - MYSQL_COLLATION_SERVER=utf8mb4_unicode_ci
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./sql:/docker-entrypoint-initdb.d
    networks:
      - verto-network
    restart: unless-stopped
    command: --default-authentication-plugin=mysql_native_password
  
  # Redis缓存
  redis:
    image: redis:6.2-alpine
    container_name: verto-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - verto-network
    restart: unless-stopped
    command: redis-server --appendonly yes
  
  # RabbitMQ消息队列
  rabbitmq:
    image: rabbitmq:3.9-management-alpine
    container_name: verto-rabbitmq
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=123456
    ports:
      - "5672:5672"
      - "15672:15672"
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    networks:
      - verto-network
    restart: unless-stopped
  
  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: verto-nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/conf.d:/etc/nginx/conf.d
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - jeecg-boot
    networks:
      - verto-network
    restart: unless-stopped

volumes:
  mysql_data:
  redis_data:
  rabbitmq_data:

networks:
  verto-network:
    driver: bridge
```

### Kubernetes配置
```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: verto

---
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: jeecg-boot-config
  namespace: verto
data:
  application.yml: |
    server:
      port: 8080
    spring:
      profiles:
        active: k8s
      datasource:
        dynamic:
          primary: master
          datasource:
            master:
              url: jdbc:mysql://mysql-service:3306/verto?characterEncoding=UTF-8&useUnicode=true&useSSL=false
              username: ${DB_USERNAME}
              password: ${DB_PASSWORD}
              driver-class-name: com.mysql.cj.jdbc.Driver
      redis:
        host: redis-service
        port: 6379
      rabbitmq:
        host: rabbitmq-service
        port: 5672
        username: ${RABBITMQ_USERNAME}
        password: ${RABBITMQ_PASSWORD}

---
# k8s/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: jeecg-boot-secret
  namespace: verto
type: Opaque
data:
  db-username: cm9vdA==  # root
  db-password: MTIzNDU2  # 123456
  rabbitmq-username: YWRtaW4=  # admin
  rabbitmq-password: MTIzNDU2  # 123456

---
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jeecg-boot-deployment
  namespace: verto
spec:
  replicas: 3
  selector:
    matchLabels:
      app: jeecg-boot
  template:
    metadata:
      labels:
        app: jeecg-boot
    spec:
      containers:
      - name: jeecg-boot
        image: verto/jeecg-boot:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "k8s"
        - name: DB_USERNAME
          valueFrom:
            secretKeyRef:
              name: jeecg-boot-secret
              key: db-username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: jeecg-boot-secret
              key: db-password
        - name: RABBITMQ_USERNAME
          valueFrom:
            secretKeyRef:
              name: jeecg-boot-secret
              key: rabbitmq-username
        - name: RABBITMQ_PASSWORD
          valueFrom:
            secretKeyRef:
              name: jeecg-boot-secret
              key: rabbitmq-password
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
        - name: logs-volume
          mountPath: /app/logs
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /jeecg-boot/actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 10
        readinessProbe:
          httpGet:
            path: /jeecg-boot/actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
      volumes:
      - name: config-volume
        configMap:
          name: jeecg-boot-config
      - name: logs-volume
        emptyDir: {}

---
# k8s/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: jeecg-boot-service
  namespace: verto
spec:
  selector:
    app: jeecg-boot
  ports:
  - protocol: TCP
    port: 8080
    targetPort: 8080
  type: ClusterIP

---
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: jeecg-boot-ingress
  namespace: verto
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  tls:
  - hosts:
    - api.verto.com
    secretName: verto-tls-secret
  rules:
  - host: api.verto.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: jeecg-boot-service
            port:
              number: 8080
```

## 总结

本文档详细描述了Verto项目后端模块的设计方案，包括：

1. **设计原则**: 分层架构、模块化、安全性
2. **技术架构**: Spring Boot生态、数据库、缓存、消息队列
3. **模块划分**: 清晰的模块结构和依赖关系
4. **核心模块**: 需求管理、应用管理等业务模块的详细设计
5. **安全认证**: JWT认证、权限控制、安全配置
6. **异常处理**: 全局异常处理、错误码规范
7. **配置管理**: 环境配置、参数管理
8. **监控告警**: 健康检查、性能监控、告警机制
9. **部署方案**: Docker、Kubernetes部署配置

该设计方案遵循微服务架构原则，具有良好的可扩展性、可维护性和可靠性，能够支撑Verto项目的长期发展需求。