# Verto项目集成指南

## 📋 项目概述

Verto是一个基于JeecgBoot框架的企业级应用开发平台，集成了完整的DevOps工具链，包括GitLab代码管理和Jenkins持续集成。

### 技术栈
- **前端**: Vue3 + Vite + TypeScript + Ant Design Vue
- **后端**: Spring Boot + MyBatis Plus + MySQL + Redis
- **DevOps**: GitLab + Jenkins + Docker + Docker Compose

## 🚀 快速集成步骤

### 1. 环境准备

#### 系统要求
```bash
# Windows 10/11 或 Windows Server 2019+
# Docker Desktop 4.0+
# Git 2.30+
# 至少 8GB RAM，推荐 16GB
# 至少 50GB 可用磁盘空间
```

#### 安装依赖
```powershell
# 安装 Docker Desktop
# 下载地址: https://www.docker.com/products/docker-desktop

# 验证安装
docker --version
docker-compose --version

# 安装 Git
# 下载地址: https://git-scm.com/download/win

# 验证安装
git --version
```

### 2. 项目初始化

#### 克隆项目
```bash
# 克隆主项目
git clone https://github.com/your-org/verto.git
cd verto

# 初始化子模块（如果有）
git submodule update --init --recursive
```

#### 配置环境变量
```bash
# 复制环境变量模板
copy .env.example .env.devops

# 编辑环境变量
notepad .env.devops
```

### 3. DevOps环境启动

#### 启动GitLab和Jenkins
```bash
# 启动DevOps服务
.\start-devops.bat

# 检查服务状态
.\devops-status.bat

# 查看服务日志
docker-compose -f docker-compose-devops.yml logs -f
```

#### 访问服务
- **GitLab**: http://localhost:8080
  - 默认用户: root
  - 密码: 查看容器日志获取初始密码
- **Jenkins**: http://localhost:8081
  - 初始密码: 查看容器日志或文件

### 4. 项目配置

#### GitLab项目设置
```bash
# 1. 创建新项目
# 登录GitLab -> New Project -> Create blank project
# 项目名: verto
# 可见性: Private

# 2. 添加远程仓库
git remote add gitlab http://localhost:8080/root/verto.git

# 3. 推送代码
git push gitlab main
```

#### Jenkins任务配置
```groovy
// 1. 创建Pipeline任务
// Jenkins -> New Item -> Pipeline -> verto-pipeline

// 2. 配置Pipeline脚本
pipeline {
    agent any
    
    stages {
        stage('检出代码') {
            steps {
                git branch: 'main', url: 'http://gitlab:8080/root/verto.git'
            }
        }
        
        stage('前端构建') {
            steps {
                dir('jeecgboot-vue3') {
                    bat 'npm install -g pnpm'
                    bat 'pnpm install'
                    bat 'pnpm build'
                }
            }
        }
        
        stage('后端构建') {
            steps {
                dir('jeecg-boot') {
                    bat 'mvn clean package -DskipTests'
                }
            }
        }
    }
}
```

## 🔧 开发环境集成

### 1. 前端开发环境

#### 安装依赖
```bash
cd jeecgboot-vue3

# 安装pnpm（如果未安装）
npm install -g pnpm

# 安装项目依赖
pnpm install
```

#### 开发服务器
```bash
# 启动开发服务器
pnpm dev

# 构建生产版本
pnpm build

# 运行测试
pnpm test

# 代码检查
pnpm lint
```

#### 环境配置
```typescript
// jeecgboot-vue3/.env.development
VITE_APP_API_BASE_URL=http://localhost:8080
VITE_APP_UPLOAD_URL=http://localhost:8080/sys/common/upload
VITE_APP_WEBSOCKET_URL=ws://localhost:8080/websocket

// jeecgboot-vue3/.env.production
VITE_APP_API_BASE_URL=https://api.verto.com
VITE_APP_UPLOAD_URL=https://api.verto.com/sys/common/upload
VITE_APP_WEBSOCKET_URL=wss://api.verto.com/websocket
```

### 2. 后端开发环境

#### 数据库配置
```yaml
# jeecg-boot/jeecg-system-start/src/main/resources/application-dev.yml
spring:
  datasource:
    dynamic:
      primary: master
      datasource:
        master:
          url: jdbc:mysql://localhost:3306/verto?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=false&serverTimezone=GMT%2B8
          username: root
          password: root123
          driver-class-name: com.mysql.cj.jdbc.Driver
  
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
    timeout: 3000ms
    lettuce:
      pool:
        max-active: 8
        max-wait: -1ms
        max-idle: 8
        min-idle: 0
```

#### 启动后端服务
```bash
cd jeecg-boot

# 使用Maven启动
mvn spring-boot:run -pl jeecg-module-system/jeecg-system-start

# 或者使用IDE启动
# 运行 JeecgSystemApplication.java
```

### 3. 数据库初始化

#### MySQL数据库
```sql
-- 创建数据库
CREATE DATABASE verto DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 创建用户
CREATE USER 'verto'@'%' IDENTIFIED BY 'verto123';
GRANT ALL PRIVILEGES ON verto.* TO 'verto'@'%';
FLUSH PRIVILEGES;

-- 导入初始数据
-- 执行 jeecg-boot/db/jeecgboot-mysql-5.7.sql
```

#### Redis配置
```bash
# 启动Redis（如果使用Docker）
docker run -d --name redis -p 6379:6379 redis:7-alpine

# 或者使用本地Redis服务
# 确保Redis服务正在运行
```

## 🔄 CI/CD集成流程

### 1. GitLab CI/CD配置

#### .gitlab-ci.yml
```yaml
stages:
  - build
  - test
  - deploy

variables:
  MAVEN_OPTS: "-Dmaven.repo.local=$CI_PROJECT_DIR/.m2/repository"

cache:
  paths:
    - .m2/repository/
    - jeecgboot-vue3/node_modules/

frontend:build:
  stage: build
  image: node:18-alpine
  script:
    - cd jeecgboot-vue3
    - npm install -g pnpm
    - pnpm install --frozen-lockfile
    - pnpm build
  artifacts:
    paths:
      - jeecgboot-vue3/dist/
    expire_in: 1 hour

backend:build:
  stage: build
  image: maven:3.8.6-openjdk-8
  script:
    - cd jeecg-boot
    - mvn clean package -DskipTests
  artifacts:
    paths:
      - jeecg-boot/target/
    expire_in: 1 hour

deploy:dev:
  stage: deploy
  script:
    - echo "部署到开发环境"
    - docker-compose -f docker-compose.dev.yml up -d
  environment:
    name: development
    url: http://dev.verto.local
  only:
    - develop
```

### 2. Jenkins Pipeline集成

#### Jenkinsfile
```groovy
pipeline {
    agent any
    
    environment {
        NODEJS_HOME = tool 'NodeJS'
        MAVEN_HOME = tool 'Maven'
        PATH = "${NODEJS_HOME}/bin:${MAVEN_HOME}/bin:${env.PATH}"
    }
    
    stages {
        stage('代码检出') {
            steps {
                git branch: 'main', 
                    url: 'http://gitlab:8080/root/verto.git',
                    credentialsId: 'gitlab-credentials'
            }
        }
        
        stage('并行构建') {
            parallel {
                stage('前端构建') {
                    steps {
                        dir('jeecgboot-vue3') {
                            bat 'pnpm install --frozen-lockfile'
                            bat 'pnpm build'
                        }
                    }
                }
                stage('后端构建') {
                    steps {
                        dir('jeecg-boot') {
                            bat 'mvn clean package -DskipTests'
                        }
                    }
                }
            }
        }
        
        stage('测试') {
            parallel {
                stage('前端测试') {
                    steps {
                        dir('jeecgboot-vue3') {
                            bat 'pnpm test:unit'
                            bat 'pnpm lint'
                        }
                    }
                }
                stage('后端测试') {
                    steps {
                        dir('jeecg-boot') {
                            bat 'mvn test'
                        }
                    }
                }
            }
        }
        
        stage('部署') {
            when {
                branch 'main'
            }
            steps {
                script {
                    bat 'docker-compose -f docker-compose.prod.yml up -d'
                }
            }
        }
    }
    
    post {
        always {
            cleanWs()
        }
        success {
            echo '构建成功！'
        }
        failure {
            echo '构建失败！'
        }
    }
}
```

## 🐳 Docker集成

### 1. 应用容器化

#### 前端Dockerfile
```dockerfile
# jeecgboot-vue3/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm install --frozen-lockfile
COPY . .
RUN pnpm build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

#### 后端Dockerfile
```dockerfile
# jeecg-boot/Dockerfile
FROM maven:3.8.6-openjdk-8 AS builder

WORKDIR /app
COPY pom.xml .
COPY jeecg-module-system/pom.xml jeecg-module-system/
RUN mvn dependency:go-offline -B

COPY . .
RUN mvn clean package -DskipTests -B

FROM openjdk:8-jre-alpine
WORKDIR /app
COPY --from=builder /app/jeecg-module-system/jeecg-system-start/target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
```

### 2. Docker Compose集成

#### 完整应用栈
```yaml
# docker-compose.yml
version: '3.8'

services:
  frontend:
    build: ./jeecgboot-vue3
    ports:
      - "3000:80"
    depends_on:
      - backend

  backend:
    build: ./jeecg-boot
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - SPRING_DATASOURCE_URL=jdbc:mysql://mysql:3306/verto
      - SPRING_REDIS_HOST=redis
    depends_on:
      - mysql
      - redis

  mysql:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=root123
      - MYSQL_DATABASE=verto
      - MYSQL_USER=verto
      - MYSQL_PASSWORD=verto123
    volumes:
      - mysql_data:/var/lib/mysql
      - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "3306:3306"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

volumes:
  mysql_data:
```

## 🔍 监控和日志集成

### 1. 应用监控

#### Spring Boot Actuator
```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true
```

#### Prometheus配置
```yaml
# prometheus.yml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'verto-backend'
    static_configs:
      - targets: ['backend:8080']
    metrics_path: '/actuator/prometheus'
```

### 2. 日志集成

#### Logback配置
```xml
<!-- jeecg-boot/src/main/resources/logback-spring.xml -->
<configuration>
    <springProfile name="!prod">
        <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        <root level="INFO">
            <appender-ref ref="CONSOLE"/>
        </root>
    </springProfile>
    
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>logs/verto.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>logs/verto.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
            </rollingPolicy>
            <encoder>
                <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            </encoder>
        </appender>
        <root level="INFO">
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
</configuration>
```

## 🔐 安全集成

### 1. 认证授权

#### JWT配置
```java
// JwtConfig.java
@Configuration
public class JwtConfig {
    
    @Value("${jeecg.jwt.secret}")
    private String secret;
    
    @Value("${jeecg.jwt.expiration}")
    private Long expiration;
    
    @Bean
    public JwtTokenUtil jwtTokenUtil() {
        return new JwtTokenUtil(secret, expiration);
    }
}
```

#### 权限控制
```java
// SecurityConfig.java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            .and()
            .authorizeRequests()
            .antMatchers("/api/auth/**").permitAll()
            .antMatchers("/api/public/**").permitAll()
            .anyRequest().authenticated()
            .and()
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
    }
}
```

### 2. 数据安全

#### 数据库加密
```yaml
# application.yml
jasypt:
  encryptor:
    password: ${JASYPT_PASSWORD:verto_secret}
    algorithm: PBEWithMD5AndDES
    iv-generator-classname: org.jasypt.iv.NoIvGenerator

spring:
  datasource:
    password: ENC(encrypted_password)
```

#### API安全
```java
// ApiSecurityInterceptor.java
@Component
public class ApiSecurityInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                           HttpServletResponse response, 
                           Object handler) throws Exception {
        // API限流
        // 签名验证
        // 参数校验
        return true;
    }
}
```

## 📊 性能优化集成

### 1. 前端优化

#### Vite配置优化
```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['vue', 'vue-router', 'pinia'],
          antd: ['ant-design-vue'],
          utils: ['lodash', 'dayjs']
        }
      }
    },
    chunkSizeWarningLimit: 1000
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true
      }
    }
  }
});
```

#### 缓存策略
```typescript
// service-worker.js
const CACHE_NAME = 'verto-v1';
const urlsToCache = [
  '/',
  '/static/css/main.css',
  '/static/js/main.js'
];

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});
```

### 2. 后端优化

#### 数据库优化
```yaml
# application.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

mybatis-plus:
  configuration:
    cache-enabled: true
    lazy-loading-enabled: true
    multiple-result-sets-enabled: true
```

#### Redis缓存
```java
// CacheConfig.java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```

---

## 💡 集成最佳实践

1. **环境隔离**: 开发、测试、生产环境完全隔离
2. **自动化部署**: 使用CI/CD实现自动化部署
3. **监控告警**: 完善的监控和告警机制
4. **安全防护**: 多层次的安全防护措施
5. **性能优化**: 前后端性能优化策略
6. **文档维护**: 保持文档的及时更新
7. **版本管理**: 规范的版本管理和发布流程

通过以上集成指南，您可以快速搭建一个完整的企业级应用开发和部署环境。